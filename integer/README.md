## 整数
### 技巧
- 快速访问和顺序都想要：map保存数组索引；数组用来保持顺序性：no 763
- 数组边界处理：需要比较左右边界来确定值：if a[i] == 0 && (i == 0 || a[i-1] == 0) && (i == len(a)-1 || a[i+1] == 0) no 605 比较种花，相邻的位置不能种花，传入n，问是否可以全部种植

### 基本概念
>  基本概念：丑数：只包含2，3，5作为质因数的正整数；1为第一个丑数 
>  
>  质因数：质数作为因子； 
>  
>  质数：只能被本身和1整除的数;从2开始；任何整数都可以分解为质数的积，大整数分解比较难；
>  
>  质数计数： n以内的所有质数：建n个数字的数组；2的倍数不是质数，标记为1；依次类推，去掉3的倍数
>  
>  no 263 判定是否丑数：依次被2或3或5整除，只剩1的话，为丑数 
>  
- 7 有符号整数反转（考察边界）: 由于反转过程中值会溢出，所以中间值和maxINT/10 和minInt/10比较
- 
- > 最大有符号整形：int32(^uint32(0)>>1),0按位取反，全为1，左移1位，则最高位为0，其余位位1
- 
- > 最小有符号整形：最大整形取反，符号位为1，其他位为0
- >
- > 最大公约数：能同时被a和b整除的最大的因数；辗转相除法：对于整数a，b 且 a>b，若a%b = c；则gcd(a,b) = gcd(b,c)，,直到c == 0 
- 
- > 最大公倍数：能同时处于a和b的最小倍数；对于a，b；LCM(a,b)=a * b / gcd(a,b) 即两数的积除以两数的最小公约数
- 
- > no 69 平方根算法：牛顿迭代：选取g一般等于n，若g*g和n之间的差距小于0.000001，则g为结果，否则g = （g + n/g）/2,其中n/g是必定小于真正的根
- 
- > no 258 对每1位相加，直到变为个位数：1 + (n-1)%9 https://en.wikipedia.org/wiki/Digital_root#Congruence_formula
- 
- > 等差数列：an = a1+(n-1)*d sum = (n*（a1+an）/2)
- 
- > no 50 求x的n次方，使用递归：关键：1. n<0,则n=-n x=1/x 2. 问题转换为mypow（x*x,n/2）,这种方法幂指数级减少，算法执行较快

- > 余数计算法则：ab%k = (a%k)*(b%k)%k

- > no 372 超级指数计算 ：问题转换为：f(a,1234567) = f(a, 1234560) * f(a, 7) % k = f(f(a, 123456),10) * f(a,7)%k; 将指数的范围限制在10以内：指数分解为：a^107 = (a^10*10)*(a^7) 

-> no 29 不使用乘法和除法的除法：使用减法；int32边界使用int64解决

- no 264 返回第n个丑数：动态规划:每个质数都需要有自己的索引
- > dp[i]个数为丑数：dp[2] = min(dp[1] * 2,dp[1]*3,dp[1]*5),dp[3] = min(dp[2] * 2,dp[1]*3,dp[1]*5)
- > 如上，状态转换需要记录2，3，5所对应的索引： dp[i] = min(dp[m]*2,dp[n]*3,dp[o]*5) 1<i<=N, 1<=m,n,o<i
- > 其他因素：会有重复值，需要去重：依次判断dp[i] 是否等于本轮计算的所有候选值
- no 1201自定义丑数: n只能被a,b,c整除，求第n个丑数
- > 问题分析：如题：则n可以被a，b，c分别整除，n可以被ab，bc，ac的最小公倍数整除；n可以被abc的最小公倍数整除
- > F(N) = N/a + N/b + N/c - N/lcm(a, c) - N/lcm(a, b) - N/lcm(b, c) + N/lcm(a, b, c)
- > 第n个：则要求F(N) == n,则N为第n个结果；二分查找；
- no 313超级丑数：定义：n的质因数必须落在给定的质数集合种，求第n个质因数,且只能被集合种的质数整除;dp[i]表示第i个丑数
- > 1.集合个数不固定，想要取最小值使用小顶堆；堆种元素要保留index，当前数对应集合中的数的位置；Val：值，每轮计算之后会更新
- > 2.对于集合中的质数k：取值范围依次是：k*1 ... k*dp[j] j属于dp集合中；每个k都需要有自己的索引
- > 3.去重和索引更新：若堆顶元素等于dp[i],更新堆顶元素对应的索引值，重新计算新的值，放入堆并调整，直到没有相同的元素
- no 202 快乐数字：n的每一位平方然后相加，重复这个过程，直到n==1  则n为快乐数
- > 两种情况：1.n最终变为1；2.无限循环，找不到值；这种情况的发生是因为出现了环，所以需要环检测机制；3.数字不可能只向上增长：999 -> 243 ,最大的3位数第一次就向下变小
- > 环检测：1.使用hashmap；2.快慢指针
- no 204 统计小于n的质数的个数，采用埃氏筛选法：n大小的数组，索引代表数值本身，值代表是否素数；k为倍数，初始为2；依次标记所有素数的倍数为1（非素数）
- no 279 计算等于n的平方和需要的最小加数个数:
- >方法DFS 1：从1开始计算小于n的所有平方和；使用回溯法计算所有可能的组合；取最小的组合
- >方法2 动态规划：sqrt[i]为i对应的平方,dp[i] 为i对应的最小平方和,1<=i<=n,dp[0]= 0；
- > 状态转换：i的结果取决于是否放入k*k，不使用k，则dp[i] = dp[i];使用k,则dp[i]=min(dp[i],dp[i-k*k]+1);1<=k 且k*k < i
- no 1954 求周长,以（0，0）为中心，半径以1为步长递增；每个点（x，y）上种植苹果的数量等于|x|+|y|,给定苹果数量，求周长
- >动态：设半径为r，则周长i=8r；每圈的苹果数：4r+8*（r *（r+2r-1）/2）=12*(r^2),则半径为r的苹果的总个数：12*1 + 12*2*2 + 12*3*3 .... + 12 * r*r
- > dp[r] = dp[r-1] + 12*r*r
- no 1131 |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|求两个数组的最大值；拆解为绝对值的组合，过滤重复问题，求解
- no 119 求杨辉三角某一行的值：建立row+1大小的数组，复用空间计算每一层；1.第一个元素arr[0] 初始为1 ;如下第0个位置不需要计算；最后一个位置总是等于0+1
```
第二行： a[1] = a[0] + a[1] = 1+0   => a = [1,1]
第三行： a[2] = a[1]+a[2] = 1+0 =1  a[1] = a[0]+a[1] = 1+1 = 2 => a = [1,2,1]
第四行： a[3] += a[2] = 0 + 1 = 1  a[2] += a[1] = 2 +1 = 3 a[1] +=a[0] = 2+1 = 3 a=[1,3,3,1]
```
- 326 判断n是否是3的k次方：1.mod和/ 2.log3(n) = log10（n）/log10（3） 3.由于题目限制是32bit整数，最大的值是3^19次方，能整除3^19的都可以被3整除
- 172 n阶乘结果结尾0的个数：计算阶乘会越界；本质是计算结尾0的个数；对于10进制数：0是由2*5 产生的；2的数量比5多很多；求解所有阶乘数字中能被5整除的数；5由1个5 25有2个5 ，同理所有能分解为5的个数累加就得到结尾0的个数
### 随机数
- 随机从剩下的数里选一个数：概率不等
- 随机选数，然后放回去；需要解决去重问题
- Fisher–Yates：洗牌算法：保证每个每个位置的概率都是1/n
- > 其核心思想是从1到n之间随机出一个数和最后一个数(n)交换，然后从1到n-1之间随机出一个数和倒数第二个数(n-1)交换...假设我们有5个数0，1，2，3，4
- no 384 将一个数组随机化，保证概率均等
- no 380 插入删除和获取任意一个数均O（1）：使用数组和map，map的值保存数组索引；插入时：数据放在数组末尾，使用map保存索引；删除时需要获取值的索引，更新末尾元素的索引为当前索引；交换当前值到末尾，从末尾删除；获取随机数直接从数组获取；
