## 字符串
### 整理
- 字符串匹配问题：
- - BF 算法：n+m, 关键是匹配失败之后的指针移动
- - RK算法：利用滚动hash做匹配；滚动hash利用上一次的hash计算本次hash，o(1)
- 子串相关问题。
- 前缀 / 后缀相关问题；
- 回文串相关问题。
- 子序列相关问题。

- 14 最长公共前缀（后缀）：依次比较每个字符，比较次数=最短字符串的长度
- 387 查找字符串第一个唯一的字符串位置：通过map计数
- no 150 逆波兰式计算结果：使用栈，当遇到符号时出栈两次，计算完毕然后入栈
- 227 字符串表达式求解：技巧：遇到减号则将后面的数字当作负数入栈，如此栈中遗留的数据可以简单执行加法
- > 关键问题：1.字符在遇到符号之前还是之后入栈？之后，初始设置符号位+，使得第一个字符入栈；之后每遇到+或/入栈后面的字符；2.如何防止重复入栈？入栈之后，当前字符清空
- > 1.循环去除非法字符和合并紧连的数字，组成数组；2.需要遍历保存当前符号位和当前数字；同时初始化当前符号位+号（方便第一个数字入栈），当前数字为-1；
- > 循环开始，为当前字符和当前符号赋值；任何字符入栈之后要设置当前字符为-1，防止重复入栈
- > 对于+ 和 -：遇到数字且数字不为-1，则数字入栈，
- > 对于* 和 /： 数字不为-1，则出栈和当前数字相乘或相除，然后入栈
- > 遍历栈，执行加法
- 394 "3[a2[c]]" = > "accaccacc" 解码字符串：使用栈：遇到],出栈，直到遇到【，将出栈的字符串入栈；注意数字可能由多位数字构成
### 子串问题：
- 暴力法：j表示母串的索引；i表示子串索引；o(mn)
- > 结束条件：j到达末尾，i未到达，则未找到；否则j-子串长度为子串的起始字符
```
<!-- 遍历母串 -->
for j < len(haystack) {
        //子串遍历完退出循环
	if i >= len(needle) {
		break
	}
	//子串和母串字母相同，则后移坐标
	if haystack[j] == needle[i] {
		i++
		j++
	} else { //不匹配，则j移动到上次相等的下一个索引，重置i
		j = j - i + 1
		i = 0
	}
}
```
- KMP算法：o（m+n）尽可能应用残余的信息；思想：利用子串匹配失败时的已经匹配的字符后缀（next[i-1]个）与子串的前缀（next[i-1]个）相同的特征，移动next[i-1]个位置，可以一次移动多步
- > 利用next数组的匹配：同暴力算法，不同的是当遇到不匹配时 i = next[i-1]计算子串的移动步数
- > next数组：next[i]=k 表示子串 p[0:i+1] 中前k个字符等于后k个字符 0<=k<i+1
- > 1.暴力构建法：
```
for i := 1; i < len(p); i++ { //控制next的索引
	for k := 1; k <= i; k++ {//控制next中前缀和后缀的个数
		if string(p[0:k]) == string(p[i-k+1:i+1]) {
			next[i] = k
		}
	}
}
```
- >2.快速构建法，子串和子串自己匹配,结构类似KMP主体
```
// now 代表next[x-1]的值，即当有now个前缀和后缀相同
for i < len(p) {
	if p[now] == p[i] { //now代表另外一个相同的p，now和i位置相同，则公共前缀个数扩展一位
		next[i] = now + 1
		now++
		i++
	} else if now != 0 { 
		now = next[now-1]
	} else {
		i++
	}
}
```

- no 28求子串的起始位置 
### 递归计算： 
- 17 电话键盘数字组合代表的字母组合穷举（递归或者队列）：1.首先构建字母相乘函数；2.关键问题，依赖中间值进行计算，中间值放入队列或者使用递归表示
- > 递归表达：ret := digit[0] * digit[1:]
### 分类问题
- no 763 标签分类：将字符串分为多个集合(不能打乱顺序)，要求每个字符串只能出现在一个集合中，输出每个集合字符的数量
- > 一种字符只能出现在一个集合：则连续的相同字符要放在一个集合;
- > 每个字符记录一个集合（起始，结束）；遇到相同字符则扩展对应字符的集合（结束位置）；
- > 最终每个字符有一个集合，且不同字符集合有交集；合并必要的集合
- no 49 字符分组：由相同字符组成的单词，分为一组： 将每个单词按字母顺序排序之后，以排序之后的单词作为key，存入map，值是数组，记录相同单词组合的原单词数组；
- no 242 判断字符是否是由相同单词组成：1.排序之后比较；2.26个单词建立数组，遍历放入相应位置；比较
### 滑动窗口算法：本质是找到所有的窗口，从这些窗口中挑选最合适的窗口大小
- 数组中连续元素的求解问题，可以归结为滑动窗口问题
- i，j 两个索引，标识窗口的起始；需要记录窗口的大小；需要数组记录每轮计算后的窗口大小和起始位置；
- 寻找j的位置，直到窗口满足特定条件；移动i，记录窗口大小，直到窗口不满足条件； 重复过程
```
for j 满足边界条件 {
    if 窗口不满足特定条件 {
    	j++
    	continue
    }
    for i<j {
    	if 不满足条件{
		i++
	} else {
		记录窗口位置
		i++
		break
	}
    }
}
```
- no 3 :求最长的无重复字符的子串：滑动窗口
- 76 求s中包含t中所有字符的最小窗口;t包含重复字符：使用map记录t的值和个数；需要另外一个map记录当前窗口中的各个合法元素和个数
- 209 求数组中和大于等于target的最小连续子数组长度： 注意：1.j的值需要在每轮都后移；2.调整i的循环，需要注意值和索引的调整
- 438 找到s中关于p的相同字母异序词 返回起始位置：滑动窗口：
- > 初始化：i，j记录边界；cnt记录p的长度；[26]int set作为map记录p中的字符
- > 扩大窗口的条件: j-i+1< len（p）；
- > 缩小窗口条件：j-i+1 == len(p)
- > 得到正确窗口的条件：j-i+1 == len(p) && winSize == 0 ；窗口中的值都落在p中；需要新的变量winSize：计算该值
```
	cnt,ok:=set[s[j]]；

	ok && cnt > 0 -> winSize-- ;
	ok && cnt >= 0 -> winSize++

```
### 编辑距离
- no 72 求两个字符串a,b的最小编辑距离 动态规划:编辑包括：增加，删除和替换
- > dp[i][j] 长度为i的字符串与长度为j的字符串的最小编辑距离；dp[0][j] = j dp[i][0] = i
- > s[i] == s[j] 则 dp[i+1][j+1] = dp[i][j] ,末尾字符相等，则无需增加计数
- >  s[i] != s[j] :综合：dp[i+1][j+1] = min(dp[i][j+1]+1,dp[i+1][j]+1,dp[i][j]+1)
- > 其中：删除末尾或者添加末尾的值：可以对应dp[i][j+1]+1 dp[i+1][j]+1 区别在于修改a还是b
- > dp[i][j]+1 则对应修改末尾值，因为长度没变，操作加1
- 127 ladder指的是仅有一个不同字符的单词构成的列表；从beiginword 到 endword的最小长度是多少？
- > 使用BFS，每层遍历，当在某层遇到最终值时，即得到最小值
- > 求只有一个不同值时，字符列表可能很大，因此在原字符串上改变某个值，取hash表里判断；len(s) * 26
- > 如何证明已经先被选择的字符，出现在其他路径不会有更优解？ 当前已经选择的字符串会被标记，其他路径无法选择；
