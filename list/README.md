## 链表
> 修改链表结构，需要保存prev指针
- no 328 将列表的第奇数个节点放在前面偶数放在后面：三个指针：1.偶数节点的头；2.奇数节点的遍历指针；3.偶数节点的遍历指针； 注意判断条件
- no 以k为一组反转链表，不够n则不反转：k=0或1 则不需要反转：反转列表函数，返回开头和结尾指针；使用递归，以k为分组进行反转；
### 快慢指针
- > p为快指针，循环结束条件（p != nil）；所有指针初始化指向head（head包含有效值）；cnt初始为1
- > k为倒数的节点个数：1.若需要找到倒数第k个元素，则当cnt>k时，慢指针开始移动；2.若需要找到倒数第k+1个元素，则cnt > k+1,慢指针开始移动
- > 边界条件:cnt==k+1时，正好有k个元素；cnt<k+1 则不够k个元素
- > 寻找中间节点：结束条件为fast!=nil && fast.next != nil,此时找到的是单数列表的对称中心，双数列表的两个中心节点的右边（第二个）节点even != nil && even.Next != nil
- no 19移除列表倒数第n个元素
- > 如何快速找到倒数第n个元素？移除倒数第n个元素，要找到倒数第n+1个元素
- > cnt > k+1,慢指针开始移动，cnt==k+1，则移除开头元素，cnt<k+1,则不够k个元素
- no 1721 交换正数和倒数第k个元素的值 ：  cnt > k 慢指针开始移动；cnt<k+1则元素

### 链表合并					       
- no 21 双列表合并 ：
- > 1. 递归法：传入3个参数：l1，l2，和新的头节点；结束条件：某个列表为nil，返回；递归结构 v1 < v2,则挂到新列表，merge(l1.Next,l2,head),否则
- > 2. 遍历法：先循环a列表，直到找到比b小的，修改a的指针指向b，然后遍历b：
- > 以 a != nil 作为循环结束条件；需要分别保存前序节点；
```
<!-- 编码细节	 -->
for a != nil && b != nil {
	for a != nil && b != nil && a.Val <= b.Val {
		prevA = a
		a = a.Next
	}
	if prevA != nil {
		prevA.Next = b
		prevA = nil
	}
	for b != nil && a != nil && b.Val.(int) <= a.Val.(int) {
		prevB = b
		b = b.Next
	}
	if prevB != nil {
		prevB.Next = a
		prevB = nil
	}
}

```
- no 23 k个列表合并 ： 每两个列表合并，合并完之后放入一个数组，递归调用					     
### 链表copy
- no 138 有随机指针的列表深度copy：问题的关键在于随机指针是跳跃的，无法在重建列表时找到目标指针
- > map建立旧表指针到新表指针的映射；第一次循环建立新列表同时建立map映射；第二次循环：根据random指针通过map找到新表random指针，为新表的节点赋值random指针
	
## 贪心算法
### 跳跃游戏：一个数组，每个值表示当前能够跳跃的最大步数，一般问题：能不能跳到最后？跳到最后需要的步数（最小，最大）
- 考虑从目的地开始，从后向前
- 贪心策略总是假设最终结果成立
- 贪心策略不是所有问题都有最优解，大多数问题都能得到整体最优解
- 自顶向下的求解过程
- no 55：问是否能跳到最后
- > 解法一：从0开始找打第一个能跳到最后的索引（num[i] >= end -i）,然后更新end值为i；若未找到则退出循环
```
for i := 0; i < positon; i++ { //一个循环里负责遍历i的同时动态更新positon，缩小循环的范围
	if nums[i] >= (positon - i) {
		positon = i
		isUpdate = true
		break
	}
}
```
- > 解法二：动态规划：dp[i] 表示能到达最后；从后往前;初始化：dp[n-1]=true; dp[i] = dp[i+k] && i+k<n（从后向前遍历nums）；0<=k<=nums[i](一重循环遍历nump[i]的值) ; 结论：dp[0] == true
- > 解法三：贪心策略：找到每个位置能够跳到的最远的位置；若最远的位置比当前的位置还小(这个条件不好找)，则返回false；farest = max(farest,nums[i]+i)
- no 45 求最少的跳数
-> 解法一：从后往前，每次找到最远的位置
```
for positon != 0 {
	for i := 0; i < positon; i++ {
		if nums[i] >= (positon - i) { //i 从0开始，保证每次找到了跳的最远的位置
			positon = i
			steps++
			break
		}
	}
}
```
-> 解法二： 动态规划：dp[i]为i到达末尾的最小跳数;dp[i] = min(dp[i+k]+1,dp[i]) i+k<len(nums) && 0=<k<=nums[i]；结论：dp[0]
-> 解法三：贪心算法：求每步的能够跳的最远距离；												  
- no 630 课程调度：优先级队列；优先截止时间近的和优先替换课程时间最长的课程，都体现了贪心策略
- > 贪心策略：1.首先以截止时间排序，防止替换时需要考虑截止时间；2.遍历课程，课程时间入队，并累加时间线；若时间线大于当前截止时间，则出队课程时间最长的课程；
- no 134 gas存的时每个加油站的油量；cost存的是从i->i+1需要消耗的油量；路是环路；问能不能环绕一圈,返回起点
- > 暴力法：计算gas[i]-cost[i] >= 0 的起点;遍历所有合适的起点，从起点开始走：每次(路径加1）%n,并计算邮箱的剩余油量，小于0或者回到起点则退出；判断是否可以抵达一圈
- > 总结算法：1.若总油量大于总cost，总会有一个解，否则没有解；2.A无法到达B，则A和B中间的都无法到达；可以直接跳到B作为新的起点