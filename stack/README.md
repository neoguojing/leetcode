
## 栈
- 32 求最长合法括号组： 1.使用栈，初始入栈-1，栈中保存字符索引，使用当前索引和栈顶索引计算合法字符长度；2.（入栈；）出栈，栈为空则入栈当前索引
###  单调栈 在栈的「先进后出」规则基础上，要求「从 栈顶 到 栈底 的元素是单调递增（或者单调递减）
- 适用于求解：左侧或者右侧第一个比当前元素大或者小的元素，时间复杂度n
- 单调递增栈：只有比栈顶元素小的元素才能直接进栈，否则需要先将栈中比当前元素小的元素出栈，再将当前元素入栈。单调递增逢小入栈
- 单调递减栈：：只有比栈顶元素大的元素才能直接进栈，否则需要先将栈中比当前元素大的元素出栈，再将当前元素入栈；单调递减逢大入栈
- 寻找左侧第一个比当前元素大的元素：使用单调递增栈
- 寻找左侧第一个比当前元素小的元素： 使用单调递减栈
- 寻找右侧第一个比当前元素大的元素：
- 寻找右侧第一个比当前元素小的元素：
```
无论哪种题型，都建议从左到右遍历元素。

查找 「比当前元素大的元素」 就用 单调递增栈，查找 「比当前元素小的元素」 就用 单调递减栈。

从 「左侧」 查找就看 「插入栈」 时的栈顶元素，从 「右侧」 查找就看 「弹出栈」 时即将插入的元素。
```
- no 84 求相邻柱状表能够表示的最大面积（以最低的高度为准）：i左边和右边大于等于i的柱子构成的面积，是i能够表示的最大面积 解法1：动态规划 2.递增栈
- no 42 墙体可以留多少水：使用递减栈
- no 496 求某个值在目标数组中顺序遍历的第一个大于该值的值；找不到则设置-1：单调栈-当前值比栈顶大，则当前值一定是栈顶的顺位第一大的值；适用map记录顺位值
- 503 :相比496，遇到最后一个数，可以跳到第一个查找：1.适用栈（递减栈），保存索引，因为值会重复；2.对于循环，适用i%n自行旋转
- 739：等几天天气才能更温暖？ 单调递减栈：遇到温度高的计算值，然后出栈；维持栈的递减
### 最小栈 能够以o(1)的时间获取最小值
- 关键问题：在最小值出栈之后，如何更新栈的最小值？ 要求栈元素按照栈的顺序排列；最小值候选也要按照入栈顺序且单调递增排列
- no 155 最小栈
- 解法1： 双栈：栈1正常的栈；栈2：保存最小值，栈顶为当前最小值；入栈时栈空或者最小值需要更新，则将当前值入栈；出栈时，栈1元素等于栈2元素，则同时出栈
- 解法2： 单栈：每个栈元素保存min，val和next，栈以单列表实现；新的元素插入头部；入栈时，栈为空则val==min，非空：则val可能不等于min；获取最小值，即获取当前元素的min


## 队列：
- 146 LRU ：最近最少使用缓存：期望：1.get时能够很快；2.缓存容量有限，在put时容量满了，能够快速淘汰掉最近最少使用的值
- > 双端队列：保留首尾指针，方便快速从首尾插入和删除数据；
- > hashmap使得快速访问，hashmap不直接保存值，而是保存队列节点指针
- > 达成get目标：使用hashmap最快；get时同时要使得当前的访问的元素更新到最前面，防止被淘汰
- > 达成put目标：1.更新某个值，需要将该值提到头部；2.容量满时先淘汰掉最后的，然后将新元素插入头部
### 单调队列：队列中元素单调递增或者递减；通常保存数组索引而非元素
>  核心：遇到大于或小于队尾的元素，从队尾删除元素；直到没有更小或更大的元素，将当前索引入队
>  特征：对于递增队列，队列头部维持当前的最大元素；递减队列相反；由于队列的基本特性：队列中的索引维持先后顺序不变，不会出现索引的相对顺序乱序的情况
```
for i := 0; i < len(nums); i++ {
	for !q.Empty() && nums[q.Back().(int)] < nums[i] { //维持队列的递增特性，从队尾删除元素
		q.PopBack()
	}
	q.Push(i)
	for q.Peak().(int) < i-k+1 {  //满足特定条件，删除队列头部元素
		q.Pop()
	}
	满足特定条件：取用队首元素
}	
```
- 239 以固定k窗口滑动，求出每个窗口最大值，并返回：如上
### 优先队列和堆
- 295 数据流中找到中位数：（排序之后位于中间位置的元素）：核心问题是如何对数据排序
- > 解法：双堆：小顶堆：较大一半的数据；大顶堆：维护较小一半的数据；可以看出小顶堆和大顶堆的堆顶元素即中位数；大顶堆在奇数时保存多一个元素。
- no 218 城市天际线
- > 输入： [left,right,height]
- >  1.将输入拆分为[left,height],[right,height],通用表达为[x,h],按照以下规则排序
- >  2.排序规则；
- >  a.x1 != x2,x值小的排前面；
- >  b.x1 == x2:
- >  若都是left点，则h大排前面，确保大的h优先被获取
- >  若都是right点，则h小排前面，确保再删除时小的被删除，大的被保留
- >  若一个是left，一个是right，则left排前面；
- >  综上：将left的h设置为负数，按照只需要按照h的升序排列即可
- >  3.使用大顶堆：初始化入堆0；遍历排序集合：
- >  4.若x为起点，则h入堆；若x为终点，则将对应的h从堆中删除；
- >  5.记录遍历的前一个h，若和当前h不相等，则输出[x,top]做为返回值
