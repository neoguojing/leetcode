
## 栈
- 32 求最长合法括号组： 1.使用栈，初始入栈-1，栈中保存字符索引，使用当前索引和栈顶索引计算合法字符长度；2.（入栈；）出栈，栈为空则入栈当前索引
### 单调栈 栈内的元素是有序的 解决数组中的范围问题，且元素只被使用一次
- 以单调栈递增为例（遇到比栈顶元素小的值，则出栈所有大于当前值的元素）：当前索引i，若a[i] < stack.Top;在84题中：则高度取：a[stack.Top];
- 跨度计算：i-栈顶的前一个值-1；因为a[i]和栈顶的下一个元素均小于a[stack.Top]，则i为右边界，栈顶的前一个值为左边界
- 最右边界为数组的长度（通常在原始数组末尾加入一个值0，作为最右元素的右边界）
- 左边界：当栈为空时，表示元素是第0个元素，跨度要做特殊处理 i-1-（-1） = i
- 适用场景： 1.当前值左边和右边的边界 2.获取之后的第一个大于或者小于当前值的值
- i和left之间的柱子均大于等于cur
```
for i := 0; i < len(heights); i++ {
	for len(stack) != 0 && heights[i] < heights[stack.Top()] { //递增栈
		cur := stack.Pop() //出栈当期求解元素：此元素的右边界（a[i]）和左边界栈顶出栈之后的新栈顶的值均小于当前值；同理左边界和右边界内（开区间）的值均大于等于当前值
		if len(stack) == 0 {  //处理栈空情形，即第一个元素       
			//业务逻辑
		}
		width := i - 1 - stack.Top() //跨度计算
		//业务逻辑
	}
	stack.Push(i)
}
```
- no 84 求相邻柱状表能够表示的最大面积（以最低的高度为准）：i左边和右边大于等于i的柱子构成的面积，是i能够表示的最大面积 解法1：动态规划 2.递增栈
- no 42 墙体可以留多少水：使用递减栈
- no 496 求某个值在目标数组中顺序遍历的第一个大于该值的值；找不到则设置-1：单调栈-当前值比栈顶大，则当前值一定是栈顶的顺位第一大的值；适用map记录顺位值
- 503 :相比496，遇到最后一个数，可以跳到第一个查找：1.适用栈（递减栈），保存索引，因为值会重复；2.对于循环，适用i%n自行旋转
- 739：等几天天气才能更温暖？ 单调递减栈：遇到温度高的计算值，然后出栈；维持栈的递减
### 最小栈 能够以o(1)的时间获取最小值
- 关键问题：在最小值出栈之后，如何更新栈的最小值？ 要求栈元素按照栈的顺序排列；最小值候选也要按照入栈顺序且单调递增排列
- no 155 最小栈
- 解法1： 双栈：栈1正常的栈；栈2：保存最小值，栈顶为当前最小值；入栈时栈空或者最小值需要更新，则将当前值入栈；出栈时，栈1元素等于栈2元素，则同时出栈
- 解法2： 单栈：每个栈元素保存min，val和next，栈以单列表实现；新的元素插入头部；入栈时，栈为空则val==min，非空：则val可能不等于min；获取最小值，即获取当前元素的min


## 队列：
- 146 LRU ：最近最少使用缓存：期望：1.get时能够很快；2.缓存容量有限，在put时容量满了，能够快速淘汰掉最近最少使用的值
- > 双端队列：保留首尾指针，方便快速从首尾插入和删除数据；
- > hashmap使得快速访问，hashmap不直接保存值，而是保存队列节点指针
- > 达成get目标：使用hashmap最快；get时同时要使得当前的访问的元素更新到最前面，防止被淘汰
- > 达成put目标：1.更新某个值，需要将该值提到头部；2.容量满时先淘汰掉最后的，然后将新元素插入头部
### 单调队列：队列中元素单调递增或者递减；通常保存数组索引而非元素
>  核心：遇到大于或小于队尾的元素，从队尾删除元素；直到没有更小或更大的元素，将当前索引入队
>  特征：对于递增队列，队列头部维持当前的最大元素；递减队列相反；由于队列的基本特性：队列中的索引维持先后顺序不变，不会出现索引的相对顺序乱序的情况
```
for i := 0; i < len(nums); i++ {
	for !q.Empty() && nums[q.Back().(int)] < nums[i] { //维持队列的递增特性，从队尾删除元素
		q.PopBack()
	}
	q.Push(i)
	for q.Peak().(int) < i-k+1 {  //满足特定条件，删除队列头部元素
		q.Pop()
	}
	满足特定条件：取用队首元素
}	
```
- 239 以固定k窗口滑动，求出每个窗口最大值，并返回：如上
### 优先队列和堆
- 295 数据流中找到中位数：（排序之后位于中间位置的元素）：核心问题是如何对数据排序
- > 解法：双堆：小顶堆：较大一半的数据；大顶堆：维护较小一半的数据；可以看出小顶堆和大顶堆的堆顶元素即中位数；大顶堆在奇数时保存多一个元素。
- no 218 城市天际线
- > 输入： [left,right,height]
- >  1.将输入拆分为[left,height],[right,height],通用表达为[x,h],按照以下规则排序
- >  2.排序规则；
- >  a.x1 != x2,x值小的排前面；
- >  b.x1 == x2:
- >  若都是left点，则h大排前面，确保大的h有限被获取
- >  若都是right点，则h小排前面，确保再删除时小的被删除，大的被保留
- >  若一个是left，一个是right，则left排前面；
- >  综上：将left的h设置为负数，按照只需要按照h的升序排列即可
- >  3.使用大顶堆：初始化入堆0；遍历排序集合：
- >  4.若x为起点，则h入堆；若x为终点，则将对应的h从堆中删除；
- >  5.记录遍历的前一个h，若和当前h不相等，则输出[x,top]做为返回值
