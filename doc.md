# 算法思路总结

## 字符串
- 14 最长公共前缀（后缀）：依次比较每个字符，比较次数=最短字符串的长度

## 整数
- 7 有符号整数反转（考察边界）: 由于反转过程中值会溢出，所以中间值和maxINT/10 和minInt/10比较
- > 最大有符号整形：int32(^uint32(0)>>1),0按位取反，全为1，左移1位，则最高位为0，其余位位1
- > 最小有符号整形：最大整形取反，符号位为1，其他位为0
## 数组
- 数组反转：首尾依次交换
- 345 数组部分反转：操作快排，首尾同时遍历；条件满足则交换；否则需要继续移动坐标

## 动态规划
- dp二维数组的求解方向：画出矩阵，要求先计算的值能够为后面计算提供解：
```
<!-- 倒金字塔填充dp -->
row ： n->0
col :  row->n
1 1 1
  1 1
    1
```
- 5 最大回文子串 516 最大回文子序列：
- > 子问题：dp[i][j]是回文需要满足什么条件？0<=i<n,i<=j<n
- > 1.s[i] == s[j] 且 dp[i+1][j-1]是回文串
- > 2.i==j
- > 3.s[i] == s[j] 且 j-i == 1
- 516 最大回文子序列，不需要连续字符
  ```
  Input: s = "bbbab"
  Output: 4 (bbbb)
  ```
- > 子问题：dp[i][j]=k，i，j所代表的子串有k个字符可构成回文；0<=i<n,i<=j<n;k<=j-i+1
- > 1j-i == 0; dp[i][j] = 1
- > 2 j-i == 1; 且 s[i] == s[j]; dp[i][j] = 2
- > 3.j-i > 1 ,s[i] == s[j];dp[i][j] = dp[i+1][j-1] + 2
- > 4.s[i] != s[j]; dp[i][j] = max(dp[i+1][j],dp[i][j-1])
- >5.2和3综合为：s[i] == [j],则;dp[i][j] = dp[i+1][j-1] + 2
