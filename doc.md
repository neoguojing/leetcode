# 算法思路总结

## 字符串
- 14 最长公共前缀（后缀）：依次比较每个字符，比较次数=最短字符串的长度
### 子串问题：
- 暴力法：j表示母串的索引；i表示子串索引；o(mn)
- > 结束条件：j到达末尾，i未到达，则未找到；否则j-子串长度为子串的起始字符
```
<!-- 遍历母串 -->
for j < len(haystack) {
        //子串遍历完退出循环
	if i >= len(needle) {
		break
	}
	//子串和母串字母相同，则后移坐标
	if haystack[j] == needle[i] {
		i++
		j++
	} else { //不匹配，则j移动到上次相等的下一个索引，重置i
		j = j - i + 1
		i = 0
	}
}
```
- KMP算法：o（m+n）尽可能应用残余的信息；思想：利用子串匹配失败是的已经匹配的字符后缀（next[i-1]个）与子串的前缀（next[i-1]个）相同的特征，移动next[i-1]个位置，可以一次移动多步
- > 利用next数组的匹配：同暴力算法，不同的是当遇到不匹配时 i = next[i-1]计算子串的移动步数
- > next数组：next[i]=k 表示子串 p[0:i+1] 中前k个字符等于后k个字符 0<=k<i+1
- > 1.暴力构建法：
```
for i := 1; i < len(p); i++ { //控制next的索引
	for k := 1; k <= i; k++ {//控制next中前缀和后缀的个数
		if string(p[0:k]) == string(p[i-k+1:i+1]) {
			next[i] = k
		}
	}
}
```
- >2.快速构建法，子串和子串自己匹配,结构类似KMP主体
```
// now 代表next[x-1]的值，即当有now个前缀和后缀相同
for i < len(p) {
	if p[now] == p[i] { //now代表另外一个相同的p，now和i位置相同，则公共前缀个数扩展一位
		next[i] = now + 1
		now++
		i++
	} else if now != 0 { 
		now = next[now-1]
	} else {
		i++
	}
}
```

- no 28求子串的起始位置 
### 递归计算： 
- 17 电话键盘数字组合代表的字母组合穷举（递归或者队列）：1.首先构建字母相乘函数；2.关键问题，依赖中间值进行计算，中间值放入队列或者使用递归表示
- > 递归表达：ret := digit[0] * digit[1:]

## 整数
>  基本概念：丑数：只包含2，3，5作为质因数的正整数；1为第一个丑数 
>  
>  质因数：质数作为因子； 
>  
>  质数：只能被本身和1整除的数;从2开始；任何整数都可以分解为质数的积，大整数分解比较难；
>  
>  质数计数： n以内的所有质数：建n个数字的数组；2的倍数不是质数，标记为1；依次类推，去掉3的倍数
>  
>  no 263 判定是否丑数：依次被2或3或5整除，只剩1的话，为丑数 
>  
- 7 有符号整数反转（考察边界）: 由于反转过程中值会溢出，所以中间值和maxINT/10 和minInt/10比较
- 
- > 最大有符号整形：int32(^uint32(0)>>1),0按位取反，全为1，左移1位，则最高位为0，其余位位1
- 
- > 最小有符号整形：最大整形取反，符号位为1，其他位为0
- >
- > 最大公约数：能同时被a和b整除的最大的因数；辗转相除法：对于整数a，b 且 a>b，若a%b = c；则gcd(a,b) = gcd(b,c)，,直到c == 0 
- 
- > 最大公倍数：能同时处于a和b的最小倍数；对于a，b；LCM(a,b)=a * b / gcd(a,b) 即两数的积除以两数的最小公约数
- 
- > no 69 平方根算法：牛顿迭代：选取g一般等于n，若g*g和n之间的差距小于0.000001，则g为结果，否则g = （g + n/g）/2,其中n/g是必定小于真正的根
- 
- > no 258 对每1位相加，直到变为个位数：1 + (n-1)%9 https://en.wikipedia.org/wiki/Digital_root#Congruence_formula
- 
- > 等差数列：an = a1+(n-1)*d sum = (n*（a1+an）/2)
- 
- > no 50 求x的n次方，使用递归：关键：1. n<0,则n=-n x=1/x 2. 问题转换为mypow（x*x,n/2）,这种方法幂指数级减少，算法执行较快

- > 余数计算法则：ab%k = (a%k)*(b%k)%k

- > no 372 超级指数计算 ：问题转换为：f(a,1234567) = f(a, 1234560) * f(a, 7) % k = f(f(a, 123456),10) * f(a,7)%k; 将指数的范围限制在10以内：质数分解为：a^107 = (a^10*10)*(a^7) 
- 
- no 264 返回第n个丑数：动态规划:每个质数都需要由自己的索引
- > dp[i]个数为丑数：dp[2] = min(dp[1] * 2,dp[1]*3,dp[1]*5),dp[3] = min(dp[2] * 2,dp[1]*3,dp[1]*5)
- > 如上，状态转换需要记录2，3，5所对应的索引： dp[i] = min(dp[m]*2,dp[n]*3,dp[o]*5) 1<i<=N, 1<=m,n,o<i
- > 其他因素：会有重复值，需要去重：依次判断dp[i] 是否等于本轮计算的所有候选值
- no 1201自定义丑数: n只能被a,b,c整除，求第n个丑数
- > 问题分析：如题：则n可以被a，b，c分别整除，n可以被ab，bc，ac的最小公倍数整除；n可以被abc的最小公倍数整除
- > F(N) = N/a + N/b + N/c - N/lcm(a, c) - N/lcm(a, b) - N/lcm(b, c) + N/lcm(a, b, c)
- > 第n个：则要求F(N) == n,则N为第n个结果；二分查找；
- no 313超级丑数：定义：n的质因数必须落在给定的质数集合种，求第n个质因数,且只能被集合种的质数整除;dp[i]表示第i个丑数
- > 1.集合个数不固定，想要取最小值使用小顶堆；堆种元素要保留index，当前数对应集合中的数的位置；Val：值，每轮计算之后会更新
- > 2.对于集合中的质数k：取值范围依次是：k*1 ... k*dp[j] j属于dp集合中；每个k都需要由自己的索引
- > 3.去重和索引更新：若堆顶元素等于dp[i],更新堆顶元素对于的索引值，重新计算新的值，放入堆并调整，直到没有相同的元素
- no 202 快乐数字：n的每一位平方然后相加，重复这个过程，直到n==1  则n为快乐数
- > 两种情况：1.n最终变为1；2.无限循环，找不到值；这种情况的发生是因为出现了环，所以需要环检测机制；3.数字不可能只向上增长：999 -> 243 ,最大的3位数第一次就向下变小
- > 环检测：1.使用hashmap；2.快慢指针
- no 204 统计小于n的质数的个数，采用埃氏筛选法：n大小的数组，索引代表数值本身，值代表是否素数；k为倍数，初始为2；依次标记所有素数的倍数为1（非素数）
- no 279 计算等于n的平方和需要的最小加数个数:
- >方法DFS 1：从1开始计算小于n的所有平方和；使用回溯法计算所有可能的组合；取最小的组合
- >方法2 动态规划：sqrt[i]为i对应的平方,dp[i] 为i对应的最小平方和,1<=i<=n,dp[0]= 0；
- > 状态转换：i的结果取决于是否放入k*k，不使用k，则dp[i] = dp[i];使用k,则dp[i]=min(dp[i],dp[i-k*k]+1);1<=k 且k*k < i
- no 1954 求周长,以（0，0）为中心，半径以1为步长递增；每个点（x，y）上种植苹果的数量等于|x|+|y|,给定苹果数量，求周长
- >动态：设半径为r，则周长i=8r；每圈的苹果数：4r+8*（r *（r+2r-1）/2）=12*(r^2),则半径为r的苹果的总个数：12*1 + 12*2*2 + 12*3*3 .... + 12 * r*r
- > dp[r] = dp[r-1] + 12*r*r
- no 1131 |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|求两个数组的最大值；拆解为绝对值的组合，过滤重复问题，求解
## 数组
- 数组反转：；
### 数组合并
- 有序数组合并：1.找到两个数组的最大或最小位置，依次比较然后选择一个填入目标位置 o（n）

- no 88 已经有序的2个数组原地合并：关键的原地合并：必须倒序合并，则不需要交换元素
- no 977 有序数组每个元素平方后输出到排序数组：取正数组和负数组，转换为两个有序数组合并；必须借用新的空间

### 集合
- 后面结果仅依赖前面结果或者后面的计算会改变前面的计算结果的-单向依赖算法模式：包含：1.后面的计算结果和前面无关，则向队列末尾插入；2.后面的计算依赖前面计算结果，则更新结果
```
ret := [][]int{arr[0]} //首元素入队
for i := 1; i < len(arr); i++ { //从1开始遍历元数据
	if 后面不依赖前面计算结果 { 
		ret = append(ret, intervals[i]) //新元素入队
	} else { //依赖前面计算结果，则更新队列尾部
		ret[len(ret)-1] = 新的值
	}
}
```
- no 986有序集合合并（取交集）：从最小或最大端开始遍历两个集合数组；不相交则跨过排序靠前的集合；相交：则取交集，跨过上边界较小的集合
- no 56 将数组中有交集的集合合并:1.首先按start坐标排序，将问题转化为前后依赖关系；2.后面的计算结果依赖前面的计算结果，利用队列计算	
### 二分查找：数组必须有序
- 模式
```
初始值： left, right := 0, len(nums)-1
循环条件： for left <= right
中值： mid := left + (right-left)/2
条件1 ： nums[mid] < target 则left = mid + 1
条件2：nums[mid] > target 则right = mid - 1
条件3：nums[mid] == target ： 寻找左值：则压迫右值right = mid - 1，寻找右值则压迫左值：left = mid + 1
未找到左值：left >= len(nums) || nums[left] != target ；未找到右值：right < 0 || nums[right] != target
```
- no 704 34 35
### 双索引法
- 345 数组部分反转：操作快排，首尾同时遍历；条件满足则交换；否则需要继续移动坐标
- 11 数组区间，求哪两个柱子之间可以灌最多的水？
- > 面积最大的灌水最多，遍历所有的柱子组合：面积计算：（j-i）* min(a[i],a[j])
- > 计算第一个和最后一个的面积。
- > 如何得到更大的面积？提高最短边的长度。从两侧分别遍历，交替提高短边的高度
## 回溯法：递归结束条件，剪枝约束条件和
### 通用模式：
```
func Backword() []string{
  backword(cond1,cond2,oneResult,&allResult)
}

<!-- cond1为回溯过滤条件；cond2为递归结束条件；oneResult为临时计算的值，allResult为所有计算的值 -->
func backword(cond1,cond2,oneResult,*allResult){
  <!--  填充本轮计算的值  -->
  if cond2 {
    *allResult = *append(allResult,oneResult)
  }
  <!--  n为每个位置可选择的值的个数，循环控制在每个位置依次尝试不同的值  -->
  for i<n {
    <!-- 过滤回溯条件   -->
    if cond1 {
     continue
    }
    <!--    选择i位置的值    -->
    backword(cond1,cond2,oneResult,*allResult)
     <!--    此处回滚上一步的操作，进行下一次尝试    -->
  }
}

```
### 算法题
- 22 根据数字生成对应对数的圆括号的组合，圆括号必须合法，先左后右
- > 问题：1.如何判定合法？即约束条件：已经放置的左括号数量大于右括号数量；2.结束条件，n对括号全部打印
- > 回溯/DFS，因为每个位置只有两种情况，因此不需要循环，而是递归两次即可
- 
## 动态规划
- dp二维数组的求解方向：画出矩阵，要求先计算的值能够为后面计算提供解：
```
<!-- 倒金字塔填充dp -->
row ： n->0
col :  row->n
1 1 1
  1 1
    1
```
### 回文
- 5 最大回文子串 516 最大回文子序列：
- > 子问题：dp[i][j]是回文需要满足什么条件？0<=i<n,i<=j<n
- > 1.s[i] == s[j] 且 dp[i+1][j-1]是回文串
- > 2.i==j
- > 3.s[i] == s[j] 且 j-i == 1
- 516 最大回文子序列，不需要连续字符
  ```
  Input: s = "bbbab"
  Output: 4 (bbbb)
  ```
- > 子问题：dp[i][j]=k，i，j所代表的子串有k个字符可构成回文；0<=i<n,i<=j<n;k<=j-i+1
- > 1j-i == 0; dp[i][j] = 1
- > 2 j-i == 1; 且 s[i] == s[j]; dp[i][j] = 2
- > 3.j-i > 1 ,s[i] == s[j];dp[i][j] = dp[i+1][j-1] + 2
- > 4.s[i] != s[j]; dp[i][j] = max(dp[i+1][j],dp[i][j-1])
- > 5.2和3综合为：s[i] == [j],则;dp[i][j] = dp[i+1][j-1] + 2
- no 214 给定一个字符串在前面加字符构成最小的回文串
- > 暴力法：反转s为rev，s[0:n-i]在大部分情况下一定使rev的子串，rev的其余部分即要补充的字符串
### 基于左右的dp
- 42 数字代表墙，求墙体的凹槽可以装多少单位的水？
- 分析：当前墙体可以乘水的单位由左右两边的墙体高度决定;
- >求解i能够乘水的单位trap[i]，求和得到能够乘水的最大值
- >i的乘水量 trap[i]由左边和右边最低的决定:trap[i] = min(left[i],right[i])-height[i]
- > trap[i] <=0.则trap[i] = 0 ；否则为trap[i]
- >left[i]和right[i]求解：动态规划
- 子问题：left[i]的值如何计算？
- >max(left[i-1],height[i-1]) : 当前左边最大值，有左边第一个值和左边的maxleft决定
- >right同理
- 238 构建一个数组，值是除自己以外的其他数的乘积,要求O(n)，不使用除法
- > 子问题：pro[i] = left[i-1] * right[i+1] ,分为左右两边求解，同42
-> left[i] = num[i-1] * left[i-1]

### 背包问题
#### 01背包：n个物品，w[i]为第i个物品的的重量，v[i]第i个物品的价值，背包承重w，要求放入的价值最大：
- > 状态转换：dp[i][j] 为前i个物品放入重量为j的背包的最大价值：两种情况决定最大价值，i放入和不放入的最大值（i-1实际代表第i个物品）
- > 1.i不放入背包的最大价值：dp[i-1][j]
- > 2.i放入背包，则背包承重变为j-w[i]:dp[i-1][j-w[i-1]]+v[i-1];此处i-1因为物品不能重复放入
- > dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i-1]]+v[i-1]);j>=w[i-1]
- > 优化空间j必须反向遍历
#### 完全背包问题：与01背包的不同在于同一个物体可以无限重复放入
- > 状态转换： dp[i][j] = max(dp[i-1][j],dp[i][j-w[i-1]]+v[i-1]);j>=w[i-1]；与01背包的不同在于dp[i][j-w[i-1]]+v[i-1])，第一维索引为i，表示i可以重复放入
- > 优化空间j必须正向遍历
- 多重背包问题：不同点在于引入了n[i] 表示第i总物品有多少个
- > 状态转换：考虑装入i物品的件数：k为装入i物品的件数（0...n[i]）= min(n[i],j/w[i])
- > dp[i][j] = max(dp[i-1][j-k*w[i]]+ k*v[i] for every k)
#### no 518 回溯算法解决重复问题代价较大，寻找dp算法解决：amount = 5, coins = [1,2,5]
- >子问题：dp[i][j] 为前i个coins组合成j的组合总数；两种情况：coins[i-1]为对应第i个硬币，使用和不使用第i个的组合数相加，决定了总的组合数
- > 1. 不使用第i个硬币的组合j的情况：j<coin[i-1];dp[i][j] = dp[i-1][j];
- > 2. 使用第i个硬币的情况，由于相同硬币可以重复使用（dp[i][j-coins[i-1]]第一维索引为i）：
- >  j>=coin[i-1]；dp[i][j] = dp[i-1][j] +dp[i][j-coins[i-1]] ; j-coins[i-1] 表示j已经加入了一个硬币i
### 其他
- no 1524 获取数组中所有子数组中和为奇数的子数组的个数 (子数组元素必须连续)；递归法超时
- > dp0[i] 表示以i为开头的子数组的和为奇数和的子数组个数；dp1[i] 相反
- > 状态转换：
- > 1.第i个元素为奇数，则dp0[i] = dp1[i+1]（奇数数组尽数转换为偶数） dp1[i] = dp0[i+1] + 1(1为第i个元素本身)
- > 2.1.第i个元素为偶数，则dp1[i] = dp0[i+1] dp0[i] = dp1[i+1] + 1(1为第i个元素本身)
- > 3.结果为dp1[i]的和
## 图
### 广度优先
### 最短路径算法（动态规划）（bellman-ford）：边的权重可以为负数，n为节点个数 时间复杂度O（VE）
- 输入：边集合：[i,j,w];点集合；距离集合Distant；起始点
- Distant[i]:为源点到i点的最短距离；初始时设置 Distant[原点] = 0，其他的为无穷大
- 松弛计算：对所有边，若Distant[j] > Distant[i] + w[i,j],则Distant[j]= Distant[i] + w[i,j]；i为边的起点，j为边的终点
- 计算最短路径：进行n-1轮的松弛计算；第一轮更新原点相隔一条表的节点；第二轮两条边可达的距离；n-1轮正好覆盖最差情况（n个节点串联）；若某轮没有更新Distant，则结束
- 负环路：权值之和为负数的环路；存在则无法求出最短路径；遍历所有边，若依然存在Distant[j] > Distant[i] + w[i,j]，则有环路，无法求解最短路径
```
dist := make([][]int, n)//到原点的距离
edges [][]int{起始点，终点，权重} //边集合，邻接矩阵
	// n-1轮循环
for i := 0; i < n-1; i++ {
	    check := false
		   // 遍历所有边，进行松弛
	for _, v := range edges {
		if dist[v[1]][0] > dist[v[0]][0]+v[2] {
			dist[v[1]][0] = dist[v[0]][0] + v[2]
			check = true
		}
	}

	if !check {
		break
	}
}	
```
- no 787 找到最多K次中转的最便宜的航班路径
- > 状态转移：dp[k][j] 为需要i次中转的终点为j的价格；0<=k<=K+2;0<=0<=n
-> dp[k][j] = min(dp[k][j],dp[k-1][i]+w[i,j])
### Dijkstra（贪心策略） ： 处理单源最短路径，边的权重不能为负数，适用于有向图和无向图，图可以包含环路 o（v^2）
- 思路：每次选取未加入集合的，离原点最近的点；加入集合，并以该点为起点，更新到原点的距离
- 输入：原点v；顶点集合；边集合包含点和权重[i,j,w]；dist[n] 原点到节点的距离；prev[]记录当前点的前一个节点；已计算的的点集合s[]
- 初始化：初始化s[v] =1,其他为0；初始化prev和dist
- 计算：遍历节点，找出未放入s的节点中，找到dist最小的，将节点放入s； 以新加入的点为起始，更新dist和prev
- 通用模式
```
  dist := make([]int, n) //保存到原点距离
	path := make([]int, n) //保存到原点path，可选
	set := make(map[int]bool) // 判定点是否被选定
  adj := make([][]int, n) //邻接矩阵，值为权重
  // 初始化
  adj[src]可发现的边初始化
  set[src]初始化
  dist和path初始化
  // 计算
  for i := 0; i < n; i++ {
       min := INF //最小值保存
		   selectNode := 0 //旋转节点保存
      //寻找节点              
      for j := 0; j < n; j++ {
        if !set[j] && dist[j] < min {
				min = dist[j]
				selectNode = j
			  }
      }
      // 保存节点                             
      set[selectNode] = true
      //从新选节点出发，更新        dist和path                     
      for j := 0; j < n; j++ {
        if !set[j] && min+adj[selectNode][j] < dist[j] {
          dist[j] = min + adj[selectNode][j]
          path[j] = selectNode
			  }
      }

  }
  
```
### Floyd：任意两个节点间的最短路径 o(v^3) 在任何图中使用，包括有向图、带负权边的图;邻接矩阵来储存边
- 思路： 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短
 ```
  For k←1 to n do // k为“媒介节点”
   For i←1 to n do
      For j←1 to n do
         if (dist(i,k) + dist(k,j) < dist(i,j)) then // 是否是更短的路径？
            dist(i,j) = dist(i,k) + dist(k,j)
 ```

## 链表
> 修改链表结构，需要保存prev指针
### 快慢指针
> p为快指针，循环结束条件（p != nil）；所有指针初始化指向head（head包含有效值）；cnt初始为1
> k为倒数的节点个数：1.若需要找到倒数第k个元素，则当cnt>k时，慢指针开始移动；2.若需要找到倒数第k+1个元素，则cnt > k+1,慢指针开始移动
> 边界条件:cnt==k+1时，正好有k个元素；cnt<k+1 则不够k个元素

- no 19移除列表倒数第n个元素
- > 如何快速找到倒数第n个元素？移除倒数第n个元素，要找到倒数第n+1个元素
- > cnt > k+1,慢指针开始移动，cnt==k+1，则移除开头元素，cnt<k+1,则不够k个元素
- no 1721 交换正数和倒数第k个元素的值 ：  cnt > k 慢指针开始移动；cnt<k+1则元素

### 链表合并					       
- no 21 双列表合并 ：
- > 1. 递归法：传入3个参数：l1，l2，和新的头节点；结束条件：某个列表为nil，返回；递归结构 v1 < v2,则挂到新列表，merge(l1.Next,l2,head),否则
- > 2. 遍历法：先循环a列表，直到找到比b小的，修改a的指针指向b，然后遍历b：
- > 以 a != nil 作为循环结束条件；需要分别保存前序节点；
```
<!-- 编码细节	 -->
for a != nil && b != nil {
	for a != nil && b != nil && a.Val <= b.Val {
		prevA = a
		a = a.Next
	}
	if prevA != nil {
		prevA.Next = b
		prevA = nil
	}
	for b != nil && a != nil && b.Val.(int) <= a.Val.(int) {
		prevB = b
		b = b.Next
	}
	if prevB != nil {
		prevB.Next = a
		prevB = nil
	}
}

```
- no 23 k个列表合并 ： 每两个列表合并，合并完之后放入一个数组，递归调用					       
						       
						       
	
