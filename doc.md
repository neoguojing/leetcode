# 算法思路总结

## 字符串
- 14 最长公共前缀（后缀）：依次比较每个字符，比较次数=最短字符串的长度
### 子串问题：
- 暴力法：j表示母串的索引；i表示子串索引；o(mn)
- > 结束条件：j到达末尾，i未到达，则未找到；否则j-子串长度为子串的起始字符
```
<!-- 遍历母串 -->
for j < len(haystack) {
        //子串遍历完退出循环
	if i >= len(needle) {
		break
	}
	//子串和母串字母相同，则后移坐标
	if haystack[j] == needle[i] {
		i++
		j++
	} else { //不匹配，则j移动到上次相等的下一个索引，重置i
		j = j - i + 1
		i = 0
	}
}
```
- KMP算法：o（m+n）尽可能应用残余的信息；思想：利用子串匹配失败是的已经匹配的字符后缀（next[i-1]个）与子串的前缀（next[i-1]个）相同的特征，移动next[i-1]个位置，可以一次移动多步
- > 利用next数组的匹配：同暴力算法，不同的是当遇到不匹配时 i = next[i-1]计算子串的移动步数
- > next数组：next[i]=k 表示子串 p[0:i+1] 中前k个字符等于后k个字符 0<=k<i+1
- > 1.暴力构建法：
```
for i := 1; i < len(p); i++ { //控制next的索引
	for k := 1; k <= i; k++ {//控制next中前缀和后缀的个数
		if string(p[0:k]) == string(p[i-k+1:i+1]) {
			next[i] = k
		}
	}
}
```
- >2.快速构建法，子串和子串自己匹配,结构类似KMP主体
```
// now 代表next[x-1]的值，即当有now个前缀和后缀相同
for i < len(p) {
	if p[now] == p[i] { //now代表另外一个相同的p，now和i位置相同，则公共前缀个数扩展一位
		next[i] = now + 1
		now++
		i++
	} else if now != 0 { 
		now = next[now-1]
	} else {
		i++
	}
}
```

- no 28求子串的起始位置 
### 递归计算： 
- 17 电话键盘数字组合代表的字母组合穷举（递归或者队列）：1.首先构建字母相乘函数；2.关键问题，依赖中间值进行计算，中间值放入队列或者使用递归表示
- > 递归表达：ret := digit[0] * digit[1:]
### 分类问题
- no 763 标签分类：将字符串分为多个集合(不能打乱顺序)，要求每个字符串只能出现在一个集合中，输出每个集合字符的数量
- > 一种字符只能出现在一个集合：则连续的相同字符要放在一个集合;
- > 每个字符记录一个集合（起始，结束）；遇到相同字符则扩展对应字符的集合（结束位置）；
- > 最终每个字符有一个集合，且不同字符集合有交集；合并必要的集合

## 二进制运算
- 负数：等于除符号位之外取反 加1； 计算机负数用补码表示
- a&(-a) : lowbit，返回a所代表的整数的最后一个1所代表的整数，用于二叉索引树
- a^b=c 则a^c=b
- no 260 有两个数出现1次，其他数出现两次：a^b = mask mask&(-mask)=lastDiff（最后一个为1的位置） 此得到的是a与b最后一个不同的位置；则a&lastDiff 或者b&lastDiff中有一个值不为0
- no 137 其他数都出现k次，仅一个数出现1次：
```
//k = 3 二进制为11，需要两位，索引用x1和x2两个数
x1, x2, mask := 0, 0, 0
for i := range nums {
	// x1为1，新来一个数，则x2需要进1；
	x2 ^= x1 & nums[i]
	// 相同为0，不同为1，第一bit计数
	x1 ^= nums[i]
	// mask作用，是当相同的数累计三次之后，清零计数器；值为0或1
	mask = ^(x1 & x2)
	// 清理计数器
	x1 = x1 & mask
	x2 = x2 & mask
}
return x1

//k = 5 二进制为101，需要3位，索引用x1和x2，x3计数
x1, x2,x3, mask := 0, 0, 0,0
for i := range nums {
	x3 ^= x2 & x1 & nums[i]
	// x1为1，新来一个数，则x2需要进1；
	x2 ^= x1 & nums[i]
	// 相同为0，不同为1，第一bit计数
	x1 ^= nums[i]
	// mask作用，是当相同的数累计5次之后，清零计数器；值为0或1
	mask = ^(x1 & ^x2 & x3)
	// 清理计数器
	x1 = x1 & mask
	x2 = x2 & mask
	x3 = x3 & mask
}
return x1
```
## 整数
### 技巧
- 快速访问和顺序都想要：map保存数组索引；数组用来保持顺序性：no 763
- 数组边界处理：需要比较左右边界来确定值：if a[i] == 0 && (i == 0 || a[i-1] == 0) && (i == len(a)-1 || a[i+1] == 0) no 605 比较种花，相邻的位置不能种花，传入n，问是否可以全部种植

### 基本概念
>  基本概念：丑数：只包含2，3，5作为质因数的正整数；1为第一个丑数 
>  
>  质因数：质数作为因子； 
>  
>  质数：只能被本身和1整除的数;从2开始；任何整数都可以分解为质数的积，大整数分解比较难；
>  
>  质数计数： n以内的所有质数：建n个数字的数组；2的倍数不是质数，标记为1；依次类推，去掉3的倍数
>  
>  no 263 判定是否丑数：依次被2或3或5整除，只剩1的话，为丑数 
>  
- 7 有符号整数反转（考察边界）: 由于反转过程中值会溢出，所以中间值和maxINT/10 和minInt/10比较
- 
- > 最大有符号整形：int32(^uint32(0)>>1),0按位取反，全为1，左移1位，则最高位为0，其余位位1
- 
- > 最小有符号整形：最大整形取反，符号位为1，其他位为0
- >
- > 最大公约数：能同时被a和b整除的最大的因数；辗转相除法：对于整数a，b 且 a>b，若a%b = c；则gcd(a,b) = gcd(b,c)，,直到c == 0 
- 
- > 最大公倍数：能同时处于a和b的最小倍数；对于a，b；LCM(a,b)=a * b / gcd(a,b) 即两数的积除以两数的最小公约数
- 
- > no 69 平方根算法：牛顿迭代：选取g一般等于n，若g*g和n之间的差距小于0.000001，则g为结果，否则g = （g + n/g）/2,其中n/g是必定小于真正的根
- 
- > no 258 对每1位相加，直到变为个位数：1 + (n-1)%9 https://en.wikipedia.org/wiki/Digital_root#Congruence_formula
- 
- > 等差数列：an = a1+(n-1)*d sum = (n*（a1+an）/2)
- 
- > no 50 求x的n次方，使用递归：关键：1. n<0,则n=-n x=1/x 2. 问题转换为mypow（x*x,n/2）,这种方法幂指数级减少，算法执行较快

- > 余数计算法则：ab%k = (a%k)*(b%k)%k

- > no 372 超级指数计算 ：问题转换为：f(a,1234567) = f(a, 1234560) * f(a, 7) % k = f(f(a, 123456),10) * f(a,7)%k; 将指数的范围限制在10以内：质数分解为：a^107 = (a^10*10)*(a^7) 

-> no 29 不使用乘法和除法的除法：使用减法；int32边界使用int64解决

- no 264 返回第n个丑数：动态规划:每个质数都需要由自己的索引
- > dp[i]个数为丑数：dp[2] = min(dp[1] * 2,dp[1]*3,dp[1]*5),dp[3] = min(dp[2] * 2,dp[1]*3,dp[1]*5)
- > 如上，状态转换需要记录2，3，5所对应的索引： dp[i] = min(dp[m]*2,dp[n]*3,dp[o]*5) 1<i<=N, 1<=m,n,o<i
- > 其他因素：会有重复值，需要去重：依次判断dp[i] 是否等于本轮计算的所有候选值
- no 1201自定义丑数: n只能被a,b,c整除，求第n个丑数
- > 问题分析：如题：则n可以被a，b，c分别整除，n可以被ab，bc，ac的最小公倍数整除；n可以被abc的最小公倍数整除
- > F(N) = N/a + N/b + N/c - N/lcm(a, c) - N/lcm(a, b) - N/lcm(b, c) + N/lcm(a, b, c)
- > 第n个：则要求F(N) == n,则N为第n个结果；二分查找；
- no 313超级丑数：定义：n的质因数必须落在给定的质数集合种，求第n个质因数,且只能被集合种的质数整除;dp[i]表示第i个丑数
- > 1.集合个数不固定，想要取最小值使用小顶堆；堆种元素要保留index，当前数对应集合中的数的位置；Val：值，每轮计算之后会更新
- > 2.对于集合中的质数k：取值范围依次是：k*1 ... k*dp[j] j属于dp集合中；每个k都需要由自己的索引
- > 3.去重和索引更新：若堆顶元素等于dp[i],更新堆顶元素对于的索引值，重新计算新的值，放入堆并调整，直到没有相同的元素
- no 202 快乐数字：n的每一位平方然后相加，重复这个过程，直到n==1  则n为快乐数
- > 两种情况：1.n最终变为1；2.无限循环，找不到值；这种情况的发生是因为出现了环，所以需要环检测机制；3.数字不可能只向上增长：999 -> 243 ,最大的3位数第一次就向下变小
- > 环检测：1.使用hashmap；2.快慢指针
- no 204 统计小于n的质数的个数，采用埃氏筛选法：n大小的数组，索引代表数值本身，值代表是否素数；k为倍数，初始为2；依次标记所有素数的倍数为1（非素数）
- no 279 计算等于n的平方和需要的最小加数个数:
- >方法DFS 1：从1开始计算小于n的所有平方和；使用回溯法计算所有可能的组合；取最小的组合
- >方法2 动态规划：sqrt[i]为i对应的平方,dp[i] 为i对应的最小平方和,1<=i<=n,dp[0]= 0；
- > 状态转换：i的结果取决于是否放入k*k，不使用k，则dp[i] = dp[i];使用k,则dp[i]=min(dp[i],dp[i-k*k]+1);1<=k 且k*k < i
- no 1954 求周长,以（0，0）为中心，半径以1为步长递增；每个点（x，y）上种植苹果的数量等于|x|+|y|,给定苹果数量，求周长
- >动态：设半径为r，则周长i=8r；每圈的苹果数：4r+8*（r *（r+2r-1）/2）=12*(r^2),则半径为r的苹果的总个数：12*1 + 12*2*2 + 12*3*3 .... + 12 * r*r
- > dp[r] = dp[r-1] + 12*r*r
- no 1131 |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|求两个数组的最大值；拆解为绝对值的组合，过滤重复问题，求解
## 数组
- 数组反转：；
### 数组合并
- 有序数组合并：1.找到两个数组的最大或最小位置，依次比较然后选择一个填入目标位置 o（n）
- 插入新的集合：1.边界处理：插入最前和最后的直接处理；2.获取插入位置；3.将前一个位置与待插入元素计算集合入队；，一次遍历剩下集合，右交集则更新队尾；无则入队
- 集合删除：1.处理边界条件：删除开头和结尾的情况；2.查询删除的起始位置；3.从起始位置开始，比较计算：4中情况：1.没有交集；2.交集导致集合分裂为两个；3.删除集合左边部分，4删除集合右边部分
- 集合查询：1.边界情况处理；2.遍历查询起始位置，查到则跳出循环，判断该集合是否包含要查询集合
- no 88 已经有序的2个数组原地合并：关键的原地合并：必须倒序合并，则不需要交换元素
- no 977 有序数组每个元素平方后输出到排序数组：取正数组和负数组，转换为两个有序数组合并；必须借用新的空间
- no 715 集合的删除、插入和查询

### 集合
- 后面结果仅依赖前面结果或者后面的计算会改变前面的计算结果的-单向依赖算法模式：包含：1.后面的计算结果和前面无关，则向队列末尾插入；2.后面的计算依赖前面计算结果，则更新结果
```
ret := [][]int{arr[0]} //首元素入队
for i := 1; i < len(arr); i++ { //从1开始遍历元数据
	if 后面不依赖前面计算结果 { 
		ret = append(ret, intervals[i]) //新元素入队
	} else { //依赖前面计算结果，则更新队列尾部
		ret[len(ret)-1] = 新的值
	}
}
```
- no 986有序集合合并（取交集）：从最小或最大端开始遍历两个集合数组；不相交则跨过排序靠前的集合；相交：则取交集，跨过上边界较小的集合
- no 56 将数组中有交集的集合合并:1.首先按start坐标排序，将问题转化为前后依赖关系；2.后面的计算结果依赖前面的计算结果，利用队列计算	
- no 57 在有序集合的数组中插入一个集合（有交集则合并）：1.找到插入位置（位置+1为要插入的元素）；2.因为有序，所以采用通用算法求解；需要保证起始时至少有一个元素 ；3.特殊情况处理插入位置小于0的情况
- no 495 反复放毒，求敌人的总中毒时间: 转换成集合，按照标准解法解题
- no 1386 每排10个座位，共n排，求解能分配多少个4人连坐；：集合思想：1.针对已经占用作为集合，计算每排的有效集合占用情况；2.根据集合占用情况，计算实际可分配的座位数量
- no 735 小行星碰撞：1.不可改变顺序；2.负数表示向左，正数表示向右；3.只有左边是正数，右边是负数的情况才会碰撞，其他情况下均不会碰撞；4.碰撞情况分析：a.左边绝对值大，什么都不做；b.绝对值相等，则需要删除左边最后一个元素；c:左边绝对值小，则需要从后向前遍历找到第一个（绝对值大的）或（相等的）或（值小于0的）或（所有的都小于）
### 二分查找：数组必须有序
- 模式
```
初始值： left, right := 0, len(nums)-1
循环条件： for left <= right
中值： mid := left + (right-left)/2
条件1 ： nums[mid] < target 则left = mid + 1
条件2：nums[mid] > target 则right = mid - 1
条件3：nums[mid] == target ： 寻找左值：则压迫右值right = mid - 1，寻找右值则压迫左值：left = mid + 1
未找到左值：left >= len(nums) || nums[left] != target ；未找到右值：right < 0 || nums[right] != target
```
- no 704 34 35
#### 有序的旋转数组查找 o(logn)
- 旋转数组特性： 
- > 1.任意取中间值，则至少右一半的区间是递增区间
- > 2.均可采用二分查重处理
- > 3.使用中间值和最右（最左）比较，是算法的核心
```
//最小值算法：中间值与最右值比较								
lo, hi, mid := 0, len(nums)-1, 0
for lo <= hi {
	mid = lo + (hi-lo)/2 
	if nums[mid] > nums[hi] { //中间值大于最右值，则右边非递增区间，最小值落在右边区域
		lo = mid + 1
	} else if nums[mid] < nums[hi] { //中间值小于最右值，则最小值值一定在左边，且有可能就是中间值
		hi = mid
	} else { //对于中间值等于最右值的情况是因为数组中有重复元素；此时不确定在哪边，则最右索引减一
		hi--
	}
}
return nums[lo]	
//查询目标值算法，无重复值
//首先上面算法查到最小值的索引，即偏移，将算法转换为二分查找				      
rot := lo //等价于一个偏移，即旋转的次数				    
lo, hi = 0, len(nums)-1
for lo <= hi {
	mid := lo + (hi-lo)/2
	realMid := (mid + rot) % len(nums)
	if nums[realMid] == target {
		return realMid
	} else if nums[realMid] < target {
		lo = mid + 1
	} else {
		hi = mid - 1
	}
}

// 查询目标值算法：标准解法，适用于重复和不重复的
for lo <= hi {
	mid := lo + (hi-lo)/2
	if nums[mid] == target { //遇到相等则返回
		return true
	}

	if nums[mid] == nums[lo] && nums[mid] == nums[hi] { //处理重复值的场景：中间值等于左右的值，则不确定在哪个区间
		hi--
		lo++
	} else if nums[mid] <= nums[hi] { //中间值小于最右值，则表示，mid-> hi是一个递增区间，适合二分查找

		if nums[mid] < target && nums[hi] >= target { //目标落在递增区间
			lo = mid + 1
		} else {                         //不在递增区间，则在另一半
			hi = mid - 1
		}
	} else { //右边不是递增区间，则左边是递增区间
		if nums[mid] > target && nums[lo] <= target { //目标在递增区间
			hi = mid - 1
		} else {   //目标不在递增区间
			lo = mid + 1
		}
	}

}					
```
- no 33 数组无重复元素
- no 81 数组有重复元素
- no 153 在旋转数组中查找最小值，无重复元素，要求o（logn），
- no 154 在旋转数组中查找最小值，有重复元素，要求o（logn）
### 双索引法
- 345 数组部分反转：操作快排，首尾同时遍历；条件满足则交换；否则需要继续移动坐标
- 11 数组区间，求哪两个柱子之间可以灌最多的水？
- > 面积最大的灌水最多，遍历所有的柱子组合：面积计算：（j-i）* min(a[i],a[j])
- > 计算第一个和最后一个的面积。
- > 如何得到更大的面积？提高最短边的长度。从两侧分别遍历，交替提高短边的高度
## 回溯法：递归结束条件，剪枝约束条件和
### 通用模式：
```
func Backword() []string{
  backword(cond1,cond2,oneResult,&allResult)
}

<!-- cond1为回溯过滤条件；cond2为递归结束条件；oneResult为临时计算的值，allResult为所有计算的值 -->
func backword(cond1,cond2,oneResult,*allResult){
  <!--  填充本轮计算的值  -->
  if cond2 {
    *allResult = *append(allResult,oneResult)
  }
  <!--  n为每个位置可选择的值的个数，循环控制在每个位置依次尝试不同的值  -->
  for i<n {
    <!-- 过滤回溯条件   -->
    if cond1 {
     continue
    }
    <!--    选择i位置的值    -->
    backword(cond1,cond2,oneResult,*allResult)
     <!--    此处回滚上一步的操作，进行下一次尝试    -->
  }
}

```
### 算法题
- 22 根据数字生成对应对数的圆括号的组合，圆括号必须合法，先左后右
- > 问题：1.如何判定合法？即约束条件：已经放置的左括号数量大于右括号数量；2.结束条件，n对括号全部打印
- > 回溯/DFS，因为每个位置只有两种情况，因此不需要循环，而是递归两次即可
- 
## 动态规划
- dp二维数组的求解方向：画出矩阵，要求先计算的值能够为后面计算提供解：
```
<!-- 倒金字塔填充dp -->
row ： n->0
col :  row->n
1 1 1
  1 1
    1
```
### 回文
- 5 最大回文子串 516 最大回文子序列：
- > 子问题：dp[i][j]是回文需要满足什么条件？0<=i<n,i<=j<n
- > 1.s[i] == s[j] 且 dp[i+1][j-1]是回文串
- > 2.i==j
- > 3.s[i] == s[j] 且 j-i == 1
- 516 最大回文子序列，不需要连续字符
  ```
  Input: s = "bbbab"
  Output: 4 (bbbb)
  ```
- > 子问题：dp[i][j]=k，i，j所代表的子串有k个字符可构成回文；0<=i<n,i<=j<n;k<=j-i+1
- > 1j-i == 0; dp[i][j] = 1
- > 2 j-i == 1; 且 s[i] == s[j]; dp[i][j] = 2
- > 3.j-i > 1 ,s[i] == s[j];dp[i][j] = dp[i+1][j-1] + 2
- > 4.s[i] != s[j]; dp[i][j] = max(dp[i+1][j],dp[i][j-1])
- > 5.2和3综合为：s[i] == [j],则;dp[i][j] = dp[i+1][j-1] + 2
- no 214 给定一个字符串在前面加字符构成最小的回文串
- > 暴力法：反转s为rev，s[0:n-i]在大部分情况下一定使rev的子串，rev的其余部分即要补充的字符串
### 基于左右的dp
- 42 数字代表墙，求墙体的凹槽可以装多少单位的水？
- 分析：当前墙体可以乘水的单位由左右两边的墙体高度决定;
- >求解i能够乘水的单位trap[i]，求和得到能够乘水的最大值
- >i的乘水量 trap[i]由左边和右边最低的决定:trap[i] = min(left[i],right[i])-height[i]
- > trap[i] <=0.则trap[i] = 0 ；否则为trap[i]
- >left[i]和right[i]求解：动态规划
- 子问题：left[i]的值如何计算？
- >max(left[i-1],height[i-1]) : 当前左边最大值，有左边第一个值和左边的maxleft决定
- >right同理
- 238 构建一个数组，值是除自己以外的其他数的乘积,要求O(n)，不使用除法
- > 子问题：pro[i] = left[i-1] * right[i+1] ,分为左右两边求解，同42
-> left[i] = num[i-1] * left[i-1]

### 背包问题
- 01问题只选定的值只有1个和0个的区别，空间优化第二重循环必须逆序
- 完全问题：选定的值可以右0个和无限个，空间优化第二重必须正序
- 求最小值问题，dp需要初始化为特大值

#### 01背包：n个物品，w[i]为第i个物品的的重量，v[i]第i个物品的价值，背包承重w，要求放入的价值最大：
- > 状态转换：dp[i][j] 为前i个物品放入重量为j的背包的最大价值：两种情况决定最大价值，i放入和不放入的最大值（i-1实际代表第i个物品）
- > 1.i不放入背包的最大价值：dp[i-1][j]
- > 2.i放入背包，则背包承重变为j-w[i]:dp[i-1][j-w[i-1]]+v[i-1];此处i-1因为物品不能重复放入
- > dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i-1]]+v[i-1]);j>=w[i-1]
- > 优化空间j必须反向遍历
#### 完全背包问题：与01背包的不同在于同一个物体可以无限重复放入 （硬币问题）
- > 状态转换： dp[i][j] = max(dp[i-1][j],dp[i][j-w[i-1]]+v[i-1]);j>=w[i-1]；与01背包的不同在于dp[i][j-w[i-1]]+v[i-1])，第一维索引为i，表示i可以重复放入
- > 优化空间j必须正向遍历
- 多重背包问题：不同点在于引入了n[i] 表示第i总物品有多少个
- > 状态转换：考虑装入i物品的件数：k为装入i物品的件数（0...n[i]）= min(n[i],j/w[i])
- > dp[i][j] = max(dp[i-1][j-k*w[i]]+ k*v[i] for every k)
#### no 518 回溯算法解决重复问题代价较大，寻找dp算法解决：amount = 5, coins = [1,2,5]
- >子问题：dp[i][j] 为前i个coins组合成j的组合总数；两种情况：coins[i-1]为对应第i个硬币，使用和不使用第i个的组合数相加，决定了总的组合数
- > 1. 不使用第i个硬币的组合j的情况：j<coin[i-1];dp[i][j] = dp[i-1][j];
- > 2. 使用第i个硬币的情况，由于相同硬币可以重复使用（dp[i][j-coins[i-1]]第一维索引为i）：
- >  j>=coin[i-1]；dp[i][j] = dp[i-1][j] +dp[i][j-coins[i-1]] ; j-coins[i-1] 表示j已经加入了一个硬币i
### 其他
- no 1524 获取数组中所有子数组中和为奇数的子数组的个数 (子数组元素必须连续)；递归法超时
- > dp0[i] 表示以i为开头的子数组的和为奇数和的子数组个数；dp1[i] 相反
- > 状态转换：
- > 1.第i个元素为奇数，则dp0[i] = dp1[i+1]（奇数数组尽数转换为偶数） dp1[i] = dp0[i+1] + 1(1为第i个元素本身)
- > 2.1.第i个元素为偶数，则dp1[i] = dp0[i+1] dp0[i] = dp1[i+1] + 1(1为第i个元素本身)
- > 3.结果为dp1[i]的和
- no 322 求银币组成amount值的需要的最小银币个数：dp[i][j] = min(dp[i-1][j],dp[i][j-coin[i]]+1 )；注意求最小值，dp要初始化为特别大的值
## 图
### 广度优先
### 最短路径算法（动态规划）（bellman-ford）：边的权重可以为负数，n为节点个数 时间复杂度O（VE）
- 输入：边集合：[i,j,w];点集合；距离集合Distant；起始点
- Distant[i]:为源点到i点的最短距离；初始时设置 Distant[原点] = 0，其他的为无穷大
- 松弛计算：对所有边，若Distant[j] > Distant[i] + w[i,j],则Distant[j]= Distant[i] + w[i,j]；i为边的起点，j为边的终点
- 计算最短路径：进行n-1轮的松弛计算；第一轮更新原点相隔一条表的节点；第二轮两条边可达的距离；n-1轮正好覆盖最差情况（n个节点串联）；若某轮没有更新Distant，则结束
- 负环路：权值之和为负数的环路；存在则无法求出最短路径；遍历所有边，若依然存在Distant[j] > Distant[i] + w[i,j]，则有环路，无法求解最短路径
```
dist := make([][]int, n)//到原点的距离
edges [][]int{起始点，终点，权重} //边集合，邻接矩阵
	// n-1轮循环
for i := 0; i < n-1; i++ {
	    check := false
		   // 遍历所有边，进行松弛
	for _, v := range edges {
		if dist[v[1]][0] > dist[v[0]][0]+v[2] {
			dist[v[1]][0] = dist[v[0]][0] + v[2]
			check = true
		}
	}

	if !check {
		break
	}
}	
```
- no 787 找到最多K次中转的最便宜的航班路径
- > 状态转移：dp[k][j] 为需要i次中转的终点为j的价格；0<=k<=K+2;0<=0<=n
-> dp[k][j] = min(dp[k][j],dp[k-1][i]+w[i,j])
### Dijkstra（贪心策略） ： 处理单源最短路径，边的权重不能为负数，适用于有向图和无向图，图可以包含环路 o（v^2）
- 思路：每次选取未加入集合的，离原点最近的点；加入集合，并以该点为起点，更新到原点的距离
- 输入：原点v；顶点集合；边集合包含点和权重[i,j,w]；dist[n] 原点到节点的距离；prev[]记录当前点的前一个节点；已计算的的点集合s[]
- 初始化：初始化s[v] =1,其他为0；初始化prev和dist
- 计算：遍历节点，找出未放入s的节点中，找到dist最小的，将节点放入s； 以新加入的点为起始，更新dist和prev
- 通用模式
```
  dist := make([]int, n) //保存到原点距离
	path := make([]int, n) //保存到原点path，可选
	set := make(map[int]bool) // 判定点是否被选定
  adj := make([][]int, n) //邻接矩阵，值为权重
  // 初始化
  adj[src]可发现的边初始化
  set[src]初始化
  dist和path初始化
  // 计算
  for i := 0; i < n; i++ {
       min := INF //最小值保存
		   selectNode := 0 //旋转节点保存
      //寻找节点              
      for j := 0; j < n; j++ {
        if !set[j] && dist[j] < min {
				min = dist[j]
				selectNode = j
			  }
      }
      // 保存节点                             
      set[selectNode] = true
      //从新选节点出发，更新        dist和path                     
      for j := 0; j < n; j++ {
        if !set[j] && min+adj[selectNode][j] < dist[j] {
          dist[j] = min + adj[selectNode][j]
          path[j] = selectNode
			  }
      }

  }
  
```
### Floyd：任意两个节点间的最短路径 o(v^3) 在任何图中使用，包括有向图、带负权边的图;邻接矩阵来储存边
- 思路： 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短
 ```
  For k←1 to n do // k为“媒介节点”
   For i←1 to n do
      For j←1 to n do
         if (dist(i,k) + dist(k,j) < dist(i,j)) then // 是否是更短的路径？
            dist(i,j) = dist(i,k) + dist(k,j)
 ```

## 链表
> 修改链表结构，需要保存prev指针
### 快慢指针
> p为快指针，循环结束条件（p != nil）；所有指针初始化指向head（head包含有效值）；cnt初始为1
> k为倒数的节点个数：1.若需要找到倒数第k个元素，则当cnt>k时，慢指针开始移动；2.若需要找到倒数第k+1个元素，则cnt > k+1,慢指针开始移动
> 边界条件:cnt==k+1时，正好有k个元素；cnt<k+1 则不够k个元素

- no 19移除列表倒数第n个元素
- > 如何快速找到倒数第n个元素？移除倒数第n个元素，要找到倒数第n+1个元素
- > cnt > k+1,慢指针开始移动，cnt==k+1，则移除开头元素，cnt<k+1,则不够k个元素
- no 1721 交换正数和倒数第k个元素的值 ：  cnt > k 慢指针开始移动；cnt<k+1则元素

### 链表合并					       
- no 21 双列表合并 ：
- > 1. 递归法：传入3个参数：l1，l2，和新的头节点；结束条件：某个列表为nil，返回；递归结构 v1 < v2,则挂到新列表，merge(l1.Next,l2,head),否则
- > 2. 遍历法：先循环a列表，直到找到比b小的，修改a的指针指向b，然后遍历b：
- > 以 a != nil 作为循环结束条件；需要分别保存前序节点；
```
<!-- 编码细节	 -->
for a != nil && b != nil {
	for a != nil && b != nil && a.Val <= b.Val {
		prevA = a
		a = a.Next
	}
	if prevA != nil {
		prevA.Next = b
		prevA = nil
	}
	for b != nil && a != nil && b.Val.(int) <= a.Val.(int) {
		prevB = b
		b = b.Next
	}
	if prevB != nil {
		prevB.Next = a
		prevB = nil
	}
}

```
- no 23 k个列表合并 ： 每两个列表合并，合并完之后放入一个数组，递归调用					     

	
## 贪心算法
### 跳跃游戏：一个数组，每个值表示当前能够跳跃的最大步数，一般问题：能不能跳到最后？跳到最后需要的步数（最小，最大）
- 考虑从目的地开始，从后向前
- 贪心策略总是假设最终结果成立
- 贪心策略不能保证最优解
- no 55：问是否能跳到最后
- > 解法一：从0开始找打第一个能跳到最后的索引（num[i] >= end -i）,然后更新end值为i；若未找到则退出循环
```
for i := 0; i < positon; i++ { //一个循环里负责遍历i的同时动态更新positon，缩小循环的范围
	if nums[i] >= (positon - i) {
		positon = i
		isUpdate = true
		break
	}
}
```
- > 解法二：动态规划：dp[i] 表示能到达最后；从后往前;初始化：dp[n-1]=true; dp[i] = dp[i+k] && i+k<n（从后向前遍历nums）；0<=k<=nums[i](一重循环遍历nump[i]的值) ; 结论：dp[0] == true
- > 解法三：贪心策略：找到每个位置能够跳到的最远的位置；若最远的位置比当前的位置还小(这个条件不好找)，则返回false；farest = max(farest,nums[i]+i)
	
