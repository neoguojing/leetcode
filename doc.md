# 算法思路总结

## 字符串
- 14 最长公共前缀（后缀）：依次比较每个字符，比较次数=最短字符串的长度
### 子串问题：
- 暴力法：j表示母串的索引；i表示子串索引；o(mn)
- > 结束条件：j到达末尾，i未到达，则未找到；否则j-子串长度为子串的起始字符
```
<!-- 遍历母串 -->
for j < len(haystack) {
        //子串遍历完退出循环
	if i >= len(needle) {
		break
	}
	//子串和母串字母相同，则后移坐标
	if haystack[j] == needle[i] {
		i++
		j++
	} else { //不匹配，则j移动到上次相等的下一个索引，重置i
		j = j - i + 1
		i = 0
	}
}
```
- KMP算法：o（m+n）尽可能应用残余的信息；思想：利用子串匹配失败是的已经匹配的字符后缀（next[i-1]个）与子串的前缀（next[i-1]个）相同的特征，移动next[i-1]个位置，可以一次移动多步
- > 利用next数组的匹配：同暴力算法，不同的是当遇到不匹配时 i = next[i-1]计算子串的移动步数
- > next数组：next[i]=k 表示子串 p[0:i+1] 中前k个字符等于后k个字符 0<=k<i+1
- > 1.暴力构建法：
```
for i := 1; i < len(p); i++ { //控制next的索引
	for k := 1; k <= i; k++ {//控制next中前缀和后缀的个数
		if string(p[0:k]) == string(p[i-k+1:i+1]) {
			next[i] = k
		}
	}
}
```
- >2.快速构建法，子串和子串自己匹配,结构类似KMP主体
```
// now 代表next[x-1]的值，即当有now个前缀和后缀相同
for i < len(p) {
	if p[now] == p[i] { //now代表另外一个相同的p，now和i位置相同，则公共前缀个数扩展一位
		next[i] = now + 1
		now++
		i++
	} else if now != 0 { 
		now = next[now-1]
	} else {
		i++
	}
}
```

- no 28求子串的起始位置 
### 递归计算： 
- 17 电话键盘数字组合代表的字母组合穷举（递归或者队列）：1.首先构建字母相乘函数；2.关键问题，依赖中间值进行计算，中间值放入队列或者使用递归表示
- > 递归表达：ret := digit[0] * digit[1:]
### 分类问题
- no 763 标签分类：将字符串分为多个集合(不能打乱顺序)，要求每个字符串只能出现在一个集合中，输出每个集合字符的数量
- > 一种字符只能出现在一个集合：则连续的相同字符要放在一个集合;
- > 每个字符记录一个集合（起始，结束）；遇到相同字符则扩展对应字符的集合（结束位置）；
- > 最终每个字符有一个集合，且不同字符集合有交集；合并必要的集合
- no 49 字符分组：由相同字符组成的单词，分为一组： 将每个单词按字母顺序排序之后，以排序之后的单词作为key，存入map，值是数组，记录相同单词组合的原单词数组；
- no 242 判断字符是否是由相同单词组成：1.排序之后比较；2.26个单词建立数组，遍历放入相应位置；比较
### 滑动窗口算法：本质是找到所有的窗口，从这些窗口中挑选最合适的窗口大小
- 数组中连续元素的求解问题，可以归结为滑动窗口问题
- i，j 两个索引，标识窗口的起始；需要记录窗口的大小；需要数组记录每轮计算后的窗口大小和起始位置；
- 寻找j的位置，直到窗口满足特定条件；移动i，记录窗口大小，直到窗口不满足条件； 重复过程
```
for j 满足边界条件 {
    if 窗口不满足特定条件 {
    	j++
    	continue
    }
    for i<j {
    	if 不满足条件{
		i++
	} else {
		记录窗口位置
		i++
		break
	}
    }
}
```
- 76 求s中包含t中所有字符的最小窗口;t包含重复字符：使用map记录t的值和个数；需要另外一个map记录当前窗口中的各个合法元素和个数
- 209 求数组中和大于等于target的最小连续子数组长度： 注意：1.j的值需要在每轮都后移；2.调整i的循环，需要注意值和索引的调整
### 编辑距离
- no 72 求两个字符串a,b的最小编辑距离 动态规划:编辑包括：增加，删除和替换
- > dp[i][j] 长度为i的字符串与长度为j的字符串的最小编辑距离；dp[0][j] = j dp[i][0] = i
- > s[i] == s[j] 则 dp[i+1][j+1] = dp[i][j] ,末尾字符相等，则无需增加计数
- >  s[i] != s[j] :综合：dp[i+1][j+1] = min(dp[i][j+1]+1,dp[i+1][j]+1,dp[i][j]+1)
- > 其中：删除末尾或者添加末尾的值：可以对应dp[i][j+1]+1 dp[i+1][j]+1 区别在于修改a还是b
- > dp[i][j]+1 则对应修改末尾值，因为长度没变，操作加1
- 127 ladder指的是仅有一个不同字符的单词构成的列表；从beiginword 到 endword的最小长度是多少？
- > 使用BFS，每层遍历，当在某层遇到最终值时，即得到最小值
- > 求只有一个不同值时，字符列表可能很大，因此在原字符串上改变某个值，取hash表里判断；len(s) * 26
- > 如何证明已经先被选择的字符，出现在其他路径不会有更优解？ 当前已经选择的字符串会被标记，其他路径无法选择；
## 二进制运算
- 负数：等于除符号位之外取反 加1； 计算机负数用补码表示
- n&(n-1) 用于统计二进制1的个数
- a&(-a) : lowbit，返回a所代表的整数的最后一个1所代表的整数，用于二叉索引树
- a^b=c 则a^c=b
- no 260 有两个数出现1次，其他数出现两次：a^b = mask mask&(-mask)=lastDiff（最后一个为1的位置） 此得到的是a与b最后一个不同的位置；则a&lastDiff 或者b&lastDiff中有一个值不为0
- no 137 其他数都出现k次，仅一个数出现1次：
```
//k = 3 二进制为11，需要两位，索引用x1和x2两个数
x1, x2, mask := 0, 0, 0
for i := range nums {
	// x1为1，新来一个数，则x2需要进1；
	x2 ^= x1 & nums[i]
	// 相同为0，不同为1，第一bit计数
	x1 ^= nums[i]
	// mask作用，是当相同的数累计三次之后，清零计数器；值为0或1
	mask = ^(x1 & x2)
	// 清理计数器
	x1 = x1 & mask
	x2 = x2 & mask
}
return x1

//k = 5 二进制为101，需要3位，索引用x1和x2，x3计数
x1, x2,x3, mask := 0, 0, 0,0
for i := range nums {
	x3 ^= x2 & x1 & nums[i]
	// x1为1，新来一个数，则x2需要进1；
	x2 ^= x1 & nums[i]
	// 相同为0，不同为1，第一bit计数
	x1 ^= nums[i]
	// mask作用，是当相同的数累计5次之后，清零计数器；值为0或1
	mask = ^(x1 & ^x2 & x3)
	// 清理计数器
	x1 = x1 & mask
	x2 = x2 & mask
	x3 = x3 & mask
}
return x1
```
## 整数
### 技巧
- 快速访问和顺序都想要：map保存数组索引；数组用来保持顺序性：no 763
- 数组边界处理：需要比较左右边界来确定值：if a[i] == 0 && (i == 0 || a[i-1] == 0) && (i == len(a)-1 || a[i+1] == 0) no 605 比较种花，相邻的位置不能种花，传入n，问是否可以全部种植

### 基本概念
>  基本概念：丑数：只包含2，3，5作为质因数的正整数；1为第一个丑数 
>  
>  质因数：质数作为因子； 
>  
>  质数：只能被本身和1整除的数;从2开始；任何整数都可以分解为质数的积，大整数分解比较难；
>  
>  质数计数： n以内的所有质数：建n个数字的数组；2的倍数不是质数，标记为1；依次类推，去掉3的倍数
>  
>  no 263 判定是否丑数：依次被2或3或5整除，只剩1的话，为丑数 
>  
- 7 有符号整数反转（考察边界）: 由于反转过程中值会溢出，所以中间值和maxINT/10 和minInt/10比较
- 
- > 最大有符号整形：int32(^uint32(0)>>1),0按位取反，全为1，左移1位，则最高位为0，其余位位1
- 
- > 最小有符号整形：最大整形取反，符号位为1，其他位为0
- >
- > 最大公约数：能同时被a和b整除的最大的因数；辗转相除法：对于整数a，b 且 a>b，若a%b = c；则gcd(a,b) = gcd(b,c)，,直到c == 0 
- 
- > 最大公倍数：能同时处于a和b的最小倍数；对于a，b；LCM(a,b)=a * b / gcd(a,b) 即两数的积除以两数的最小公约数
- 
- > no 69 平方根算法：牛顿迭代：选取g一般等于n，若g*g和n之间的差距小于0.000001，则g为结果，否则g = （g + n/g）/2,其中n/g是必定小于真正的根
- 
- > no 258 对每1位相加，直到变为个位数：1 + (n-1)%9 https://en.wikipedia.org/wiki/Digital_root#Congruence_formula
- 
- > 等差数列：an = a1+(n-1)*d sum = (n*（a1+an）/2)
- 
- > no 50 求x的n次方，使用递归：关键：1. n<0,则n=-n x=1/x 2. 问题转换为mypow（x*x,n/2）,这种方法幂指数级减少，算法执行较快

- > 余数计算法则：ab%k = (a%k)*(b%k)%k

- > no 372 超级指数计算 ：问题转换为：f(a,1234567) = f(a, 1234560) * f(a, 7) % k = f(f(a, 123456),10) * f(a,7)%k; 将指数的范围限制在10以内：质数分解为：a^107 = (a^10*10)*(a^7) 

-> no 29 不使用乘法和除法的除法：使用减法；int32边界使用int64解决

- no 264 返回第n个丑数：动态规划:每个质数都需要由自己的索引
- > dp[i]个数为丑数：dp[2] = min(dp[1] * 2,dp[1]*3,dp[1]*5),dp[3] = min(dp[2] * 2,dp[1]*3,dp[1]*5)
- > 如上，状态转换需要记录2，3，5所对应的索引： dp[i] = min(dp[m]*2,dp[n]*3,dp[o]*5) 1<i<=N, 1<=m,n,o<i
- > 其他因素：会有重复值，需要去重：依次判断dp[i] 是否等于本轮计算的所有候选值
- no 1201自定义丑数: n只能被a,b,c整除，求第n个丑数
- > 问题分析：如题：则n可以被a，b，c分别整除，n可以被ab，bc，ac的最小公倍数整除；n可以被abc的最小公倍数整除
- > F(N) = N/a + N/b + N/c - N/lcm(a, c) - N/lcm(a, b) - N/lcm(b, c) + N/lcm(a, b, c)
- > 第n个：则要求F(N) == n,则N为第n个结果；二分查找；
- no 313超级丑数：定义：n的质因数必须落在给定的质数集合种，求第n个质因数,且只能被集合种的质数整除;dp[i]表示第i个丑数
- > 1.集合个数不固定，想要取最小值使用小顶堆；堆种元素要保留index，当前数对应集合中的数的位置；Val：值，每轮计算之后会更新
- > 2.对于集合中的质数k：取值范围依次是：k*1 ... k*dp[j] j属于dp集合中；每个k都需要由自己的索引
- > 3.去重和索引更新：若堆顶元素等于dp[i],更新堆顶元素对于的索引值，重新计算新的值，放入堆并调整，直到没有相同的元素
- no 202 快乐数字：n的每一位平方然后相加，重复这个过程，直到n==1  则n为快乐数
- > 两种情况：1.n最终变为1；2.无限循环，找不到值；这种情况的发生是因为出现了环，所以需要环检测机制；3.数字不可能只向上增长：999 -> 243 ,最大的3位数第一次就向下变小
- > 环检测：1.使用hashmap；2.快慢指针
- no 204 统计小于n的质数的个数，采用埃氏筛选法：n大小的数组，索引代表数值本身，值代表是否素数；k为倍数，初始为2；依次标记所有素数的倍数为1（非素数）
- no 279 计算等于n的平方和需要的最小加数个数:
- >方法DFS 1：从1开始计算小于n的所有平方和；使用回溯法计算所有可能的组合；取最小的组合
- >方法2 动态规划：sqrt[i]为i对应的平方,dp[i] 为i对应的最小平方和,1<=i<=n,dp[0]= 0；
- > 状态转换：i的结果取决于是否放入k*k，不使用k，则dp[i] = dp[i];使用k,则dp[i]=min(dp[i],dp[i-k*k]+1);1<=k 且k*k < i
- no 1954 求周长,以（0，0）为中心，半径以1为步长递增；每个点（x，y）上种植苹果的数量等于|x|+|y|,给定苹果数量，求周长
- >动态：设半径为r，则周长i=8r；每圈的苹果数：4r+8*（r *（r+2r-1）/2）=12*(r^2),则半径为r的苹果的总个数：12*1 + 12*2*2 + 12*3*3 .... + 12 * r*r
- > dp[r] = dp[r-1] + 12*r*r
- no 1131 |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|求两个数组的最大值；拆解为绝对值的组合，过滤重复问题，求解
- no 119 求杨辉三角某一行的值：建立row+1大小的数组，复用空间计算每一层；1.第一个元素arr[0] 初始为1 ;如下第0个位置不需要计算；最后一个位置总是等于0+1
```
第二行： a[1] = a[0] + a[1] = 1+0   => a = [1,1]
第三行： a[2] = a[1]+a[2] = 1+0 =1  a[1] = a[0]+a[1] = 1+1 = 2 => a = [1,2,1]
第四行： a[3] += a[2] = 0 + 1 = 1  a[2] += a[1] = 2 +1 = 3 a[1] +=a[0] = 2+1 = 3 a=[1,3,3,1]
```
## 数组
- no 27 原地移除指定的元素：从后往前遍历，遇到相同的则和最后位置交换；最后位置用一个变量标记
- no 169 找到数组中个数超过一半的元素 o(1) 空间
- > 1. map记录 2. 排序然后找到中间元素 3.随机：从数组随机取一个数，遍历数组判断出现的次数 4.摩尔投票算法：需要候选者和计数器；计数器为0则更换候选者；候选者和当前元素一样，则计数器增加，否则计数器减少
- no 217 判断数组是否有重复值：1.暴力循环；2.排序然后遍历；3.hashmap
- 283 原地将0移动到末尾，并不改变元素相对顺序： 双指针：慢指针记录0的位置（没有0则保持和快指针一致）；块指针遇到非0的值与慢指针交换
### 数组合并
- 有序数组合并：1.找到两个数组的最大或最小位置，依次比较然后选择一个填入目标位置 o（n）
- 插入新的集合：1.边界处理：插入最前和最后的直接处理；2.获取插入位置；3.将前一个位置与待插入元素计算集合入队；，一次遍历剩下集合，右交集则更新队尾；无则入队
- 集合删除：1.处理边界条件：删除开头和结尾的情况；2.查询删除的起始位置；3.从起始位置开始，比较计算：4中情况：1.没有交集；2.交集导致集合分裂为两个；3.删除集合左边部分，4删除集合右边部分
- 集合查询：1.边界情况处理；2.遍历查询起始位置，查到则跳出循环，判断该集合是否包含要查询集合
- no 88 已经有序的2个数组原地合并：关键的原地合并：必须倒序合并，则不需要交换元素
- no 977 有序数组每个元素平方后输出到排序数组：取正数组和负数组，转换为两个有序数组合并；必须借用新的空间
- no 715 集合的删除、插入和查询

### 集合
- 后面结果仅依赖前面结果或者后面的计算会改变前面的计算结果的-单向依赖算法模式：包含：1.后面的计算结果和前面无关，则向队列末尾插入；2.后面的计算依赖前面计算结果，则更新结果
```
ret := [][]int{arr[0]} //首元素入队
for i := 1; i < len(arr); i++ { //从1开始遍历元数据
	if 后面不依赖前面计算结果 { 
		ret = append(ret, intervals[i]) //新元素入队
	} else { //依赖前面计算结果，则更新队列尾部
		ret[len(ret)-1] = 新的值
	}
}
```
- no 986有序集合合并（取交集）：从最小或最大端开始遍历两个集合数组；不相交则跨过排序靠前的集合；相交：则取交集，跨过上边界较小的集合
- no 56 将数组中有交集的集合合并:1.首先按start坐标排序，将问题转化为前后依赖关系；2.后面的计算结果依赖前面的计算结果，利用队列计算	
- no 57 在有序集合的数组中插入一个集合（有交集则合并）：1.找到插入位置（位置+1为要插入的元素）；2.因为有序，所以采用通用算法求解；需要保证起始时至少有一个元素 ；3.特殊情况处理插入位置小于0的情况
- no 495 反复放毒，求敌人的总中毒时间: 转换成集合，按照标准解法解题
- no 1386 每排10个座位，共n排，求解能分配多少个4人连坐；：集合思想：1.针对已经占用作为集合，计算每排的有效集合占用情况；2.根据集合占用情况，计算实际可分配的座位数量
- no 735 小行星碰撞：1.不可改变顺序；2.负数表示向左，正数表示向右；3.只有左边是正数，右边是负数的情况才会碰撞，其他情况下均不会碰撞；4.碰撞情况分析：a.左边绝对值大，什么都不做；b.绝对值相等，则需要删除左边最后一个元素；c:左边绝对值小，则需要从后向前遍历找到第一个（绝对值大的）或（相等的）或（值小于0的）或（所有的都小于）

			 
### 二分查找：数组必须有序
- 模式
```
初始值： left, right := 0, len(nums)-1
循环条件： for left <= right
中值： mid := left + (right-left)/2
条件1 ： nums[mid] < target 则left = mid + 1
条件2：nums[mid] > target 则right = mid - 1
条件3：nums[mid] == target ： 寻找左值：则压迫右值right = mid - 1，寻找右值则压迫左值：left = mid + 1
未找到左值：left >= len(nums) || nums[left] != target ；未找到右值：right < 0 || nums[right] != target
```
- no 704 34 35
#### 有序的旋转数组查找 o(logn)
- 旋转数组特性： 
- > 1.任意取中间值，则至少右一半的区间是递增区间
- > 2.均可采用二分查重处理
- > 3.使用中间值和最右（最左）比较，是算法的核心
```
//最小值算法：中间值与最右值比较								
lo, hi, mid := 0, len(nums)-1, 0
for lo <= hi {
	mid = lo + (hi-lo)/2 
	if nums[mid] > nums[hi] { //中间值大于最右值，则右边非递增区间，最小值落在右边区域
		lo = mid + 1
	} else if nums[mid] < nums[hi] { //中间值小于最右值，则最小值值一定在左边，且有可能就是中间值
		hi = mid
	} else { //对于中间值等于最右值的情况是因为数组中有重复元素；此时不确定在哪边，则最右索引减一
		hi--
	}
}
return nums[lo]	
//查询目标值算法，无重复值
//首先上面算法查到最小值的索引，即偏移，将算法转换为二分查找				      
rot := lo //等价于一个偏移，即旋转的次数				    
lo, hi = 0, len(nums)-1
for lo <= hi {
	mid := lo + (hi-lo)/2
	realMid := (mid + rot) % len(nums)
	if nums[realMid] == target {
		return realMid
	} else if nums[realMid] < target {
		lo = mid + 1
	} else {
		hi = mid - 1
	}
}

// 查询目标值算法：标准解法，适用于重复和不重复的
for lo <= hi {
	mid := lo + (hi-lo)/2
	if nums[mid] == target { //遇到相等则返回
		return true
	}

	if nums[mid] == nums[lo] && nums[mid] == nums[hi] { //处理重复值的场景：中间值等于左右的值，则不确定在哪个区间
		hi--
		lo++
	} else if nums[mid] <= nums[hi] { //中间值小于最右值，则表示，mid-> hi是一个递增区间，适合二分查找

		if nums[mid] < target && nums[hi] >= target { //目标落在递增区间
			lo = mid + 1
		} else {                         //不在递增区间，则在另一半
			hi = mid - 1
		}
	} else { //右边不是递增区间，则左边是递增区间
		if nums[mid] > target && nums[lo] <= target { //目标在递增区间
			hi = mid - 1
		} else {   //目标不在递增区间
			lo = mid + 1
		}
	}

}					
```
- no 33 数组无重复元素
- no 81 数组有重复元素
- no 153 在旋转数组中查找最小值，无重复元素，要求o（logn），
- no 154 在旋转数组中查找最小值，有重复元素，要求o（logn）
#### 无须数组，找丢失的整数问题 要求o（n）o(1)
- 利用数组的位置做最小值计数
- 取负数法
- 亦或法							 
- no 41 在无序数组中，找到丢失的最小正整数: 将nums[i]=4 放到数组第4-1的位置；循环直到所有数组都正确放置；结论：找到第一个nums[i]!=i+1的值；循环里嵌套循环（第二层循环并非全量循环，算做o（1）
- no 268 給定n个数字（0-n），找到丢失的数字：1.将数字放入对应的索引位置；未放置的位置即未丢失的数字；2.ret^i^nums[i]
- no 448 给定1-n的数字，有重复，返回丢失的k个数字：1.将数字放入对应索引的位置；标记重复值的位置为-1，统计-1的位置为结果；2.将nums[i]值对应位置的值置为负数，最后统计为正数的位置
### 双索引法
- 345 数组部分反转：操作快排，首尾同时遍历；条件满足则交换；否则需要继续移动坐标
- 11 数组区间，求哪两个柱子之间可以灌最多的水？
- > 面积最大的灌水最多，遍历所有的柱子组合：面积计算：（j-i）* min(a[i],a[j])
- > 计算第一个和最后一个的面积。
- > 如何得到更大的面积？提高最短边的长度。从两侧分别遍历，交替提高短边的高度
## 回溯法：递归结束条件，剪枝约束条件和
### 通用模式：
```
func Backword() []string{
  backword(cond1,cond2,oneResult,&allResult)
}

<!-- cond1为回溯过滤条件；cond2为递归结束条件；oneResult为临时计算的值，allResult为所有计算的值 -->
func backword(cond1,cond2,oneResult,*allResult){
  <!--  填充本轮计算的值  -->
  if cond2 {
    *allResult = *append(allResult,oneResult)
  }
  <!--  n为每个位置可选择的值的个数，循环控制在每个位置依次尝试不同的值  -->
  for i<n {
    <!-- 过滤回溯条件   -->
    if cond1 {
     continue
    }
    <!--    选择i位置的值    -->
    backword(cond1,cond2,oneResult,*allResult)
     <!--    此处回滚上一步的操作，进行下一次尝试    -->
  }
}

```
### 算法题
- 22 根据数字生成对应对数的圆括号的组合，圆括号必须合法，先左后右
- > 问题：1.如何判定合法？即约束条件：已经放置的左括号数量大于右括号数量；2.结束条件，n对括号全部打印
- > 回溯/DFS，因为每个位置只有两种情况，因此不需要循环，而是递归两次即可
- 
## 动态规划
- 求走法，种类等问题：如91，62 70等，到达某个解的种类是固定的比如1步还是两步，比如向下还是向右，比如一个字母还是两个字母，通常类型dp[i] = dp[i-1]+dp[i-2]
- 求最短，求最长等，通常涉及到max和min的求解
- 数组范围：需要分左和右dp两部分求解

### 普通
- no 91 1->A 26->Z 由数字组成的字符串，求有多少种解码方法：dp[i]表示字符串长度为i有多少种编码法：类似楼梯，两个字符，要么1个字符：dp[i] = dp[i-1]+ dp[i-2] 两个字符有一定限制
- no 62 机器人从左上角走到右下角的总数，自能向下和向右：dp[i][j] 表示走到（i，j）有多少种走法；由于只能向下和向右，所以第0列和第0行只有一种走法：当i=0，dp[0][j] = 1 同理dp[i][0]=1
- > dp[i][j] = dp[i-1][j] + dp[i][j-1] 到（i,j) 的走法总数，等于从上边走的总数+从左边过来的总数
- no 63 同62,格子中加了障碍，遇到障碍，则dp[i][j] = 0
- no 64 同62，求所有路径中的最小路径：dp[i][j] 表示最小路径长度 ：dp[i][j] = min(dp[i][j-1],dp[i-1][j])+grid[i][j]
- no 70 爬梯子，一步或两步，求总共有多少趴法：dp[0] = 0, dp[1] = 1 dp[2] = 2; dp[i]表示到i的爬法有多少种：到达i，要么爬两阶，要么爬1阶，则dp[i] = dp[i-1][i+1]
### 回文
- 5 最大回文子串 ：必要条件：(s[start] == s[end] && (end - start <= 2 || dp[start + 1][end - 1])
- > 子问题：dp[i][j]是回文需要满足什么条件？0<=i<n,i<=j<n
- > 1.s[i] == s[j] 且 dp[i+1][j-1]是回文串
- > 2.s[i] == s[j] j - i <= 2
- 516 最大回文子序列，不需要连续字符
  ```
  Input: s = "bbbab"
  Output: 4 (bbbb)
  ```
- > 子问题：dp[i][j]=k，i，j所代表的子串有k个字符可构成回文；0<=i<n,i<=j<n;k<=j-i+1
- > 1j-i == 0; dp[i][j] = 1
- > 2 j-i == 1; 且 s[i] == s[j]; dp[i][j] = 2
- > 3.j-i > 1 ,s[i] == s[j];dp[i][j] = dp[i+1][j-1] + 2
- > 4.s[i] != s[j]; dp[i][j] = max(dp[i+1][j],dp[i][j-1])
- > 5.2和3综合为：s[i] == [j],则;dp[i][j] = dp[i+1][j-1] + 2
- no 214 给定一个字符串在前面加字符构成最小的回文串
- > 暴力法：反转s为rev，s[0:n-i]在大部分情况下一定使rev的子串，rev的其余部分即要补充的字符串
- no 125 判断字符串是否是回文：开始和结尾比较，不相等则返回false；去掉除数字和字母外的其他字符
- 630 去掉最多一个字符是否是回文?: 双指针，于到不相等的i+1 或j-1 ，使用递归判断子串
- 131 字符串进行分组，每个分组都是回文，问字符串有多少种分组：核心问题是组合问题，使用回溯（dfs）算法
- > dfs：关键：传递一个起始位置，分组保存和最终结果；1.遍历字符串从起始位置开始；取子串：[起始位置：i+1]；2.每轮的剪枝条件：新的子串是否是回文；3.可以使用备忘录记录已经计算过的回文
- > dfs 和dp的结合：dp参考no 5
- 132 将字符串切割为回文，求可以最少切割多少次？
- > dfs + dp 会超时
- > dp: dp[i][j] 判断是否是回文；cut[k] 表示0->k需要的最少切割次数；1.无回文的情况下cut[k] = k(每个字符切割1次)；2.有回文的情况下：若dp[i][j]是回文，则cut[j] = cut[i-1] + 1;当i为0是，cut[j] = 0
### 基于左右的dp
- 42 数字代表墙，求墙体的凹槽可以装多少单位的水？
- 分析：当前墙体可以乘水的单位由左右两边的墙体高度决定;
- >求解i能够乘水的单位trap[i]，求和得到能够乘水的最大值
- >i的乘水量 trap[i]由左边和右边最低的决定:trap[i] = min(left[i],right[i])-height[i]
- > trap[i] <=0.则trap[i] = 0 ；否则为trap[i]
- >left[i]和right[i]求解：动态规划
- 子问题：left[i]的值如何计算？
- >max(left[i-1],height[i-1]) : 当前左边最大值，有左边第一个值和左边的maxleft决定
- >right同理
- 238 构建一个数组，值是除自己以外的其他数的乘积,要求O(n)，不使用除法
- > 子问题：pro[i] = left[i-1] * right[i+1] ,分为左右两边求解，同42
-> left[i] = num[i-1] * left[i-1]

### 背包问题
- 01问题只选定的值只有1个和0个的区别，空间优化第二重循环必须逆序
- 完全问题：选定的值可以右0个和无限个，空间优化第二重必须正序
- 求最小值问题，dp需要初始化为特大值

#### 01背包：n个物品，w[i]为第i个物品的的重量，v[i]第i个物品的价值，背包承重w，要求放入的价值最大：
- > 状态转换：dp[i][j] 为前i个物品放入重量为j的背包的最大价值：两种情况决定最大价值，i放入和不放入的最大值（i-1实际代表第i个物品）
- > 1.i不放入背包的最大价值：dp[i-1][j]
- > 2.i放入背包，则背包承重变为j-w[i]:dp[i-1][j-w[i-1]]+v[i-1];此处i-1因为物品不能重复放入
- > dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i-1]]+v[i-1]);j>=w[i-1]
- > 优化空间j必须反向遍历
#### 完全背包问题：与01背包的不同在于同一个物体可以无限重复放入 （硬币问题）
- > 状态转换： dp[i][j] = max(dp[i-1][j],dp[i][j-w[i-1]]+v[i-1]);j>=w[i-1]；与01背包的不同在于dp[i][j-w[i-1]]+v[i-1])，第一维索引为i，表示i可以重复放入
- > 优化空间j必须正向遍历
- 多重背包问题：不同点在于引入了n[i] 表示第i总物品有多少个
- > 状态转换：考虑装入i物品的件数：k为装入i物品的件数（0...n[i]）= min(n[i],j/w[i])
- > dp[i][j] = max(dp[i-1][j-k*w[i]]+ k*v[i] for every k)
#### no 518 回溯算法解决重复问题代价较大，寻找dp算法解决：amount = 5, coins = [1,2,5]
- >子问题：dp[i][j] 为前i个coins组合成j的组合总数；两种情况：coins[i-1]为对应第i个硬币，使用和不使用第i个的组合数相加，决定了总的组合数
- > 1. 不使用第i个硬币的组合j的情况：j<coin[i-1];dp[i][j] = dp[i-1][j];
- > 2. 使用第i个硬币的情况，由于相同硬币可以重复使用（dp[i][j-coins[i-1]]第一维索引为i）：
- >  j>=coin[i-1]；dp[i][j] = dp[i-1][j] +dp[i][j-coins[i-1]] ; j-coins[i-1] 表示j已经加入了一个硬币i
### 其他
- no 1524 获取数组中所有子数组中和为奇数的子数组的个数 (子数组元素必须连续)；递归法超时
- > dp0[i] 表示以i为开头的子数组的和为奇数和的子数组个数；dp1[i] 相反
- > 状态转换：
- > 1.第i个元素为奇数，则dp0[i] = dp1[i+1]（奇数数组尽数转换为偶数） dp1[i] = dp0[i+1] + 1(1为第i个元素本身)
- > 2.1.第i个元素为偶数，则dp1[i] = dp0[i+1] dp0[i] = dp1[i+1] + 1(1为第i个元素本身)
- > 3.结果为dp1[i]的和
- no 322 求银币组成amount值的需要的最小银币个数：dp[i][j] = min(dp[i-1][j],dp[i][j-coin[i]]+1 )；注意求最小值，dp要初始化为特别大的值
## 图
- 邻接表：适合稀疏图，求解入度和度不方便，空间复杂度o(v+e)或o(v+2e)：1.需要点集合（点的数组）,每个点保存一个列表，存储以该点为起点的所有边；2.边结构存储边的末尾节点，以及下一条边的指针
- 邻接矩阵：适合稠密矩阵；空间负责度o(v^2)
### 广度优先
### 最短路径算法（动态规划）（bellman-ford）：边的权重可以为负数，n为节点个数 时间复杂度O（VE）
- 输入：边集合：[i,j,w];点集合；距离集合Distant；起始点
- Distant[i]:为源点到i点的最短距离；初始时设置 Distant[原点] = 0，其他的为无穷大
- 松弛计算：对所有边，若Distant[j] > Distant[i] + w[i,j],则Distant[j]= Distant[i] + w[i,j]；i为边的起点，j为边的终点
- 计算最短路径：进行n-1轮的松弛计算；第一轮更新原点相隔一条表的节点；第二轮两条边可达的距离；n-1轮正好覆盖最差情况（n个节点串联）；若某轮没有更新Distant，则结束
- 负环路：权值之和为负数的环路；存在则无法求出最短路径；遍历所有边，若依然存在Distant[j] > Distant[i] + w[i,j]，则有环路，无法求解最短路径
```
dist := make([][]int, n)//到原点的距离
edges [][]int{起始点，终点，权重} //边集合，邻接矩阵
	// n-1轮循环
for i := 0; i < n-1; i++ {
	    check := false
		   // 遍历所有边，进行松弛
	for _, v := range edges {
		if dist[v[1]][0] > dist[v[0]][0]+v[2] {
			dist[v[1]][0] = dist[v[0]][0] + v[2]
			check = true
		}
	}

	if !check {
		break
	}
}	
```
- no 787 找到最多K次中转的最便宜的航班路径
- > 状态转移：dp[k][j] 为需要i次中转的终点为j的价格；0<=k<=K+2;0<=0<=n
-> dp[k][j] = min(dp[k][j],dp[k-1][i]+w[i,j])
### Dijkstra（贪心策略） ： 处理单源最短路径，边的权重不能为负数，适用于有向图和无向图，图可以包含环路 o（v^2）
- 思路：每次选取未加入集合的，离原点最近的点；加入集合，并以该点为起点，更新到原点的距离
- 输入：原点v；顶点集合；边集合包含点和权重[i,j,w]；dist[n] 原点到节点的距离；prev[]记录当前点的前一个节点；已计算的的点集合s[]
- 初始化：初始化s[v] =1,其他为0；初始化prev和dist
- 计算：遍历节点，找出未放入s的节点中，找到dist最小的，将节点放入s； 以新加入的点为起始，更新dist和prev
- 通用模式
```
  dist := make([]int, n) //保存到原点距离
	path := make([]int, n) //保存到原点path，可选
	set := make(map[int]bool) // 判定点是否被选定
  adj := make([][]int, n) //邻接矩阵，值为权重
  // 初始化
  adj[src]可发现的边初始化
  set[src]初始化
  dist和path初始化
  // 计算
  for i := 0; i < n; i++ {
       min := INF //最小值保存
		   selectNode := 0 //旋转节点保存
      //寻找节点              
      for j := 0; j < n; j++ {
        if !set[j] && dist[j] < min {
				min = dist[j]
				selectNode = j
			  }
      }
      // 保存节点                             
      set[selectNode] = true
      //从新选节点出发，更新        dist和path                     
      for j := 0; j < n; j++ {
        if !set[j] && min+adj[selectNode][j] < dist[j] {
          dist[j] = min + adj[selectNode][j]
          path[j] = selectNode
			  }
      }

  }
  
```
### Floyd：任意两个节点间的最短路径 o(v^3) 在任何图中使用，包括有向图、带负权边的图;邻接矩阵来储存边
- 思路： 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短
 ```
  For k←1 to n do // k为“媒介节点”
   For i←1 to n do
      For j←1 to n do
         if (dist(i,k) + dist(k,j) < dist(i,j)) then // 是否是更短的路径？
            dist(i,j) = dist(i,k) + dist(k,j)
 ```
### 拓扑排序 适用于DAG 有向无环图
- Kahn算法：优先将入度为0的节点从图上删除，排列，直到所有节点均排列完成；需要所有点的入度和一个队列；每次出对计数一次；若最终计数不等于总的节点数，则有环
```
q := NewQueue()
cnt := 0
//入度为0，入队
for i, in := range ins {
	if in == 0 {
		q.Push(i)
	}
}
<!-- 没有则有环 -->
if q.Empty() {
	return ret
}

for !q.Empty() {
	point := q.Pop()
	//cnt，统计访问次数
	cnt++
	ret = append(ret, point.(int))
	for _, edge := range prerequisites {
		if edge[1] == point {
			ins[edge[0]]--
			if ins[edge[0]] == 0 {
				q.Push(edge[0])
			}
		}
	}
}
<!-- 节点数和访问次数不相等，有环  -->
if cnt != numCourses {
	return []int{}
}
return ret
```
- DFS算法： 优先访问出度为0的节点
- > 1.建立数据的邻接表；2.建立已访问节点集合；3.遍历所有节点，调用dfs；4.dfs优先判断节点状态：0未访问，1 正在访问（该状态有环，直接返回false），2该节点的所有边都被访问（返回true）；5.dfs中遍历该节点的所有边，递归调用dfs；6.dfs中设置节点状态为2，并将当前节点放入结果集；7.结果集的逆向为顺序
```
主函数
res := []int{}
for i := 0; i < Vnum; i++ {
	if !dfs(graph, visited, i, &res) {
		return []int{}
	}
}
result := make([]int, 0)
for i := numCourses - 1; i >= 0; i-- {
	result = append(result, res[i])
}
	
dfs
func dfs(graph, visited []int, cur int, res *[]int) bool {
	if visited[cur] == 1 {
		return false
	} else if visited[cur] == 2 {
		return true
	} else {
		visited[cur] = 1
	}

	for i := 0; i < len(graph[cur]); i++ {
		if !dfs(graph, visited, graph[cur][i], res) {
			return false
		}
	}

	*res = append(*res, course)
	visited[cur] = 2
	return true
}
```
- no 207 210
- BFS算法 ： 在求解某些最小路径时会有效
```
q := NewQueue()
q.Push(begin) //源如队
for !q.Empty() { //非空
	qsize := q.Len() //获取当前队列长度
	for i := 0; i < qsize; i++ {  //遍历当前层，将当前层所有元素出队
		p := q.Pop().(string) 
		if 条件判断 {
			for i := 0; i < n; i++ {//遍历源数据集

			}
		}

		
	}
}					
``` 
- no 127
## 链表
> 修改链表结构，需要保存prev指针
### 快慢指针
- > p为快指针，循环结束条件（p != nil）；所有指针初始化指向head（head包含有效值）；cnt初始为1
- > k为倒数的节点个数：1.若需要找到倒数第k个元素，则当cnt>k时，慢指针开始移动；2.若需要找到倒数第k+1个元素，则cnt > k+1,慢指针开始移动
- > 边界条件:cnt==k+1时，正好有k个元素；cnt<k+1 则不够k个元素
- > 寻找中间节点：结束条件为fast!=nil && fast.next != nil,此时找到的是单数列表的对称中心，双数列表的两个中心节点的右边（第二个）节点
- no 19移除列表倒数第n个元素
- > 如何快速找到倒数第n个元素？移除倒数第n个元素，要找到倒数第n+1个元素
- > cnt > k+1,慢指针开始移动，cnt==k+1，则移除开头元素，cnt<k+1,则不够k个元素
- no 1721 交换正数和倒数第k个元素的值 ：  cnt > k 慢指针开始移动；cnt<k+1则元素

### 链表合并					       
- no 21 双列表合并 ：
- > 1. 递归法：传入3个参数：l1，l2，和新的头节点；结束条件：某个列表为nil，返回；递归结构 v1 < v2,则挂到新列表，merge(l1.Next,l2,head),否则
- > 2. 遍历法：先循环a列表，直到找到比b小的，修改a的指针指向b，然后遍历b：
- > 以 a != nil 作为循环结束条件；需要分别保存前序节点；
```
<!-- 编码细节	 -->
for a != nil && b != nil {
	for a != nil && b != nil && a.Val <= b.Val {
		prevA = a
		a = a.Next
	}
	if prevA != nil {
		prevA.Next = b
		prevA = nil
	}
	for b != nil && a != nil && b.Val.(int) <= a.Val.(int) {
		prevB = b
		b = b.Next
	}
	if prevB != nil {
		prevB.Next = a
		prevB = nil
	}
}

```
- no 23 k个列表合并 ： 每两个列表合并，合并完之后放入一个数组，递归调用					     

	
## 贪心算法
### 跳跃游戏：一个数组，每个值表示当前能够跳跃的最大步数，一般问题：能不能跳到最后？跳到最后需要的步数（最小，最大）
- 考虑从目的地开始，从后向前
- 贪心策略总是假设最终结果成立
- 贪心策略不是所有问题都有最优解，大多数问题都能得到整体最优解
- 自顶向下的求解过程
- no 55：问是否能跳到最后
- > 解法一：从0开始找打第一个能跳到最后的索引（num[i] >= end -i）,然后更新end值为i；若未找到则退出循环
```
for i := 0; i < positon; i++ { //一个循环里负责遍历i的同时动态更新positon，缩小循环的范围
	if nums[i] >= (positon - i) {
		positon = i
		isUpdate = true
		break
	}
}
```
- > 解法二：动态规划：dp[i] 表示能到达最后；从后往前;初始化：dp[n-1]=true; dp[i] = dp[i+k] && i+k<n（从后向前遍历nums）；0<=k<=nums[i](一重循环遍历nump[i]的值) ; 结论：dp[0] == true
- > 解法三：贪心策略：找到每个位置能够跳到的最远的位置；若最远的位置比当前的位置还小(这个条件不好找)，则返回false；farest = max(farest,nums[i]+i)
- no 45 求最少的跳数
-> 解法一：从后往前，每次找到最远的位置
```
for positon != 0 {
	for i := 0; i < positon; i++ {
		if nums[i] >= (positon - i) { //i 从0开始，保证每次找到了跳的最远的位置
			positon = i
			steps++
			break
		}
	}
}
```
-> 解法二： 动态规划：dp[i]为i到达末尾的最小跳数;dp[i] = min(dp[i+k]+1,dp[i]) i+k<len(nums) && 0=<k<=nums[i]；结论：dp[0]
-> 解法三：贪心算法：求每步的能够跳的最远距离；												  
- no 630 课程调度：优先级队列；优先截止时间近的和优先替换课程时间最长的课程，都体现了贪心策略
- 贪心策略：1.首先以截止时间排序，防止替换时需要考虑截止时间；2.遍历课程，课程时间入队，并累加时间线；若时间线大于当前截止时间，则出队课程时间最长的课程；
## 矩阵
### 矩阵旋转：顺时针90度：则转置+左右变化；逆时针90度：则转置+上下变化;旋转180度：则等于旋转2个90度
-  转置：i:=0 j:=i+1 matrix[i][j] = matrix[j][i]
- 旋转的坐标变化： 90度： i,j => j,n-i-1  180度：i,j => n-i-1,n-j-1 270度：i,j => n-j-1, i
- no 73 将矩阵为0的行和列置为0 空间复杂度为1；1.使用第一行和第一列保存需要置0的行和列；需要先确认第0行和列是否需要置0
- no 36 判断数独是否合法：即每行，每列和3*3格子无重复元素；使用map，分别对行和列已经格子的元素判断重复，使用字符串拼接
- no 48 n*n的矩阵，原地顺时针旋转90度；
- no 1886 确认矩阵是否通过旋转可以得到目标矩阵（90度，180 270）：使用坐标转换公式，依次比较；初始数据要置为true
### 矩阵螺旋遍历
- 使用4个遍变量分别标记行和列的起始和结束位置；一个变量标记方向；循环结束条件是起始小于结束
- no 54 矩阵的顺时针螺旋排序输出
- no 59 1-n平方的数填到n*n的矩阵里
- no 885 从某点开始以顺时针螺旋状步长为1，遍历整个矩阵，可以溢出到矩阵外面；返回遍历路径
- > 行列起始和结束需要表示，方向需要表示；结束条件为行列头尾需要在合法范围内；在向右遍历完之后，扩大行列头尾的范围；注意：需要考虑角上元素是否重复
### 矩阵搜索
- 维护已访问位置，防止出现环；在条件失败时，需要重置位置
```
	if 目标索引越界 返回
	if 矩阵越界 返回
	if 位置已访问 返回
	if 条件不满足 返回
	
	上下左右分别递归
	返回
```
- no 79 在由字母构成的图中，检索是否存在单词；位置需要连续
## 排序
### 列表排序 一般使用归并排序 o(nlogn) o(1)
- 列表获取中值：添加一个虚拟头，两个指针，一个移动2步，一个移动一步；条件是：快指针不等于nil和next不能nil； 注意，最终需要拿到的是中值的前值，然后需要断掉中值直接的链接
- 归并：添加一个虚拟头，遍历依次顺着虚拟头插入；需要一个指针记录当前位置
-  no 128 对一个列表进行排序：归并排序，获取中止，递归，然后合并
- no 147 列表的插入排序：需要一个虚拟头；一个p指向当前位置；注意：每轮循环结束，已旋转列表的头需要重置
### 有限元素类型的排序问题
- no 75 三种颜色，0，1，2，将相同颜色连在一起，且按照0，1，2的顺序排序
- > 因为值的个数是3种，我们只关心0和2（首尾），排好序后，中间的就是1
- > 算法实现： 两个变量，记录当前最后一个0和最前一个2的位置；遍历数组，遇到2交换到后面；重新判断当前位置为1则继续，为0则交换到前面的位置继续

## 栈
### 单调栈 站内的元素是有序的 解决数组中的范围问题，且元素只被使用一次
- 以单调栈递增为例（遇到比栈顶元素小的值，则出栈所有大于当前值的元素）：当前的较小的元素，即栈顶元素的右边界；而栈中除栈顶外的下一个元素（小于等于栈顶）即栈顶值的左边界
- 跨度计算：i-1-栈顶的前一个值
- 最右边界为数组的长度（通常在原始数组末尾加入一个值0，作为最右元素的右边界）
- 左边界：当栈为空时，表示元素是第0个元素，跨度要做特殊处理 i-1-（-1） = i
- 适用场景： 1.当前值左边和右边的边界 2.获取之后的第一个大于或者小于当前值的值
```
for i := 0; i < len(heights); i++ {
	for len(stack) != 0 && heights[i] < heights[stack.Top()] { //递增栈
		cur := stack.Pop() //出栈当期求解元素
		if len(stack) == 0 {  //处理栈空情形，即第一个元素       
			//业务逻辑
		}
		width := i - 1 - stack.Top() //跨度计算
		//业务逻辑
	}
	stack.Push(i)
}
```
- no 84 求相邻柱状表能够表示的最大面积（以最低的高度为准）：i左边和右边大于等于i的柱子构成的面积，是i能够表示的最大面积 解法1：动态规划 2.递增栈
- no 42 墙体可以留多少水：使用递减栈
- no 85 求某个值在目标数组中顺序遍历的第一个大于该值的值；找不到则设置-1：单调数组-当前值比栈顶大，则当前值一定是栈顶的顺位第一大的值；适用map记录顺位值
- 503 :相比85，遇到最后一个数，可以跳到第一个查找：1.适用栈（递减栈），保存索引，因为值会重复；2.对于循环，适用i%n自行旋转
### 最小栈 能够以o(1)的时间获取最小值
- 关键问题：在最小值出栈之后，如何更新栈的最小值？ 要求栈元素按照栈的顺序排列；最小值候选也要按照入栈顺序且单调递增排列
- no 155 最小栈
- 解法1： 双栈：栈1正常的栈；栈2：保存最小值，栈顶为当前最小值；入栈时栈空或者最小值需要更新，则将当前值入栈；出栈时，栈1元素等于栈2元素，则同时出栈
- 解法2： 单栈：每个栈元素保存min，val和next，栈以单列表实现；新的元素插入头部；入栈时，栈为空则val==min，非空：则val可能不等于min；获取最小值，即获取当前元素的min
## 树
### 二叉树 
- 先序：中左右 中序：左中右 后序：左右中
- 基于栈的遍历：循环条件栈不为空（中序情况下加上当前节点不为nil）；原则：先访问的后入栈
- 1.先序：根先入栈；右子树先入栈，左子树后入栈；
- 2.中序：根不入栈；左子树全部入栈；出栈（访问）；当前指针指向右节点
- 3.后序：原则：根在栈底，随后右子树，随后左子树；根入栈两次;出栈；右节点入栈两次；左节点入栈两次； 入栈两次节点的意义：第一次用于最终的遍历输出；第二次用于找到该节点的左右节点（）
- no 101 判断二叉树是否中心对称：使用递归
- no 103 z型遍历：1.和层序遍历一样，只需要记录方向，在逆向是反转数组；2.反转遍历改为从后往前插入
### 二叉树搜索树
- no 98 二叉搜索树（左小右大）是否合法，中序遍历：1.先判断根节点取有效整数范围（以int64最大和最小为边界）；2.左子树的取值范围（-minint64,root) ，右节点（root，maxint64）；3.先判断根，然后判断左子树，左子树正确才判断右子树
### 构建二叉树 有中序遍历可以唯一确定一颗二叉树，前序和后续遍历不能够唯一确定一棵树
- 先序遍历的特点，第一个元素是根节点；依据左右子树节点的个数，可以划分左右子树
- 中序遍历特点：根节点的左侧属于左子树，能够依据根节点，划分左右子树；根节点索引的位置，可以计算左右子树节点的个数
- 后续遍历的特点：最后一个为根；依据左右节点的个数，可以划分左右子树
- 105 依据先序遍历和中序遍历构造二叉树：1.依据先序遍历的第一个节点，建立根；2.找到中序遍历中的根的索引；对于先序遍历依据中序遍历根索引位置，可以确认左右子树的个数；3.递归建立左子树和右子树
- 106 依据中序遍历和后续遍历，还原二叉树：1.依据后序遍历的最后一个节点，建立根；2.找到中序遍历的根节点索引，计算左右子树的节点个数；3.递归建立左右子树
- 889 通过先序和后续遍历构建二叉树：以先序遍历第一个节点作为根，若根的值不等于后序遍历的当前值，则递归左子树和右子树
- 108 有序数组转换为平衡二叉搜索树：适用二分查找，中间位置为树根，左右为左右子树，适用递归
- 109 右序列表构建平衡二叉搜索树：同上，适用快慢指针寻找中间位置
### 多叉树遍历 中序遍历无意义
- 先序遍历：1.使用栈；2.递归，子节点从左到右递归
- 后序遍历：1.递归：先遍历子节点递归，然后访问根节点
### BFS 广度优先遍历 使用queue  层序遍历，使用q的size作为出栈入栈的数量控制
- 429 多叉树的层序遍历；1.根节点入堆；2.出队直到队列为空：访问元素，并收集下层的所有节点；3.遍历下层节点，入队
- no 102 二叉树的层序遍历：同429，只是需要判断left 或right是否为空
### LCA 问题 最近公共祖先问题
- 235 二叉搜索树的两个元素的公共祖先：由于搜索树的特性：若根大于p小于q则根是公共祖先；q,p比根小，则根指向左子树，否则同理：1.递归；2.遍历 技巧(root.val -p.val) * (root.val-q.val) > 0
- 236 普通二叉搜索树的的LCA问题：1.使用层序遍历，遍历树，标记节点的父节点，构成并查集；遍历并查集，直到p和q的祖先一样；2.递归：边界 root 为nil，root为p或q，则返回root；分别递归左边和右边，根据左边和右边的值（nil 或非 nil）筛选结果
### trie 前缀树
- 用于自动完成字符，字符搜索，前缀搜索等，功能包括：插入，搜索和前缀搜索
- 实现：1.根不存储数据；2.节点：a.是否是页节点；b.一个map
```
type TrieNode struct {
	isLeaf   bool
	children map[rune]*TrieNode
}
```
- no 208 648 211
## 并查集 ： 看似不相交的集合的：1.合并 2.查询
- 首先需要一个集合，保存每个元素和它的父亲（可以是本身）
- 某些条件导致元素的父亲变化：比如树或者图的连接
- 功能：1.查询元素的祖先；2 对于有共同祖先的可以合并
- 适用问题：LAC（最近共同祖先）236 235
- no 200 ：1表示岛屿，矩阵范围外和0表示水，四面环水为岛屿；求有多少个岛；所有为1的的岛屿标记为并查集合；对相邻的1进行合并
