# 算法思路总结

## 字符串
- 14 最长公共前缀（后缀）：依次比较每个字符，比较次数=最短字符串的长度

### 递归计算：
- 17 电话键盘数字组合代表的字母组合穷举（递归或者队列）：1.首先构建字母相乘函数；2.关键问题，依赖中间值进行计算，中间值放入队列或者使用递归表示
- > 递归表达：ret := digit[0] * digit[1:]

## 整数
- 7 有符号整数反转（考察边界）: 由于反转过程中值会溢出，所以中间值和maxINT/10 和minInt/10比较
- > 最大有符号整形：int32(^uint32(0)>>1),0按位取反，全为1，左移1位，则最高位为0，其余位位1
- > 最小有符号整形：最大整形取反，符号位为1，其他位为0
## 数组
- 数组反转：首尾依次交换

### 双索引法
- 345 数组部分反转：操作快排，首尾同时遍历；条件满足则交换；否则需要继续移动坐标
- 11 数组区间，求哪两个柱子之间可以灌最多的水？
- > 面积最大的灌水最多，遍历所有的柱子组合：面积计算：（j-i）* min(a[i],a[j])
- > 计算第一个和最后一个的面积。
- > 如何得到更大的面积？提高最短边的长度。从两侧分别遍历，交替提高短边的高度

## 回溯法：递归结束条件，剪枝约束条件和
### 通用模式：
```
func Backword() []string{
  backword(cond1,cond2,oneResult,&allResult)
}

<!-- cond1为回溯过滤条件；cond2为递归结束条件；oneResult为临时计算的值，allResult为所有计算的值 -->
func backword(cond1,cond2,oneResult,*allResult){
  <!--  填充本轮计算的值  -->
  if cond2 {
    *allResult = *append(allResult,oneResult)
  }
  <!--  n为每个位置可选择的值的个数，循环控制在每个位置依次尝试不同的值  -->
  for i<n {
    <!-- 过滤回溯条件   -->
    if cond1 {
     continue
    }
    <!--    选择i位置的值    -->
    backword(cond1,cond2,oneResult,*allResult)
     <!--    此处回滚上一步的操作，进行下一次尝试    -->
  }
}

```
### 算法题
- 22 根据数字生成对应对数的圆括号的组合，圆括号必须合法，先左后右
- > 问题：1.如何判定合法？即约束条件：已经放置的左括号数量大于右括号数量；2.结束条件，n对括号全部打印
- > 子问题
- 
## 动态规划
- dp二维数组的求解方向：画出矩阵，要求先计算的值能够为后面计算提供解：
```
<!-- 倒金字塔填充dp -->
row ： n->0
col :  row->n
1 1 1
  1 1
    1
```
### 回文
- 5 最大回文子串 516 最大回文子序列：
- > 子问题：dp[i][j]是回文需要满足什么条件？0<=i<n,i<=j<n
- > 1.s[i] == s[j] 且 dp[i+1][j-1]是回文串
- > 2.i==j
- > 3.s[i] == s[j] 且 j-i == 1
- 516 最大回文子序列，不需要连续字符
  ```
  Input: s = "bbbab"
  Output: 4 (bbbb)
  ```
- > 子问题：dp[i][j]=k，i，j所代表的子串有k个字符可构成回文；0<=i<n,i<=j<n;k<=j-i+1
- > 1j-i == 0; dp[i][j] = 1
- > 2 j-i == 1; 且 s[i] == s[j]; dp[i][j] = 2
- > 3.j-i > 1 ,s[i] == s[j];dp[i][j] = dp[i+1][j-1] + 2
- > 4.s[i] != s[j]; dp[i][j] = max(dp[i+1][j],dp[i][j-1])
- >5.2和3综合为：s[i] == [j],则;dp[i][j] = dp[i+1][j-1] + 2
### 基于左右的dp
- 42 数字代表墙，求墙体的凹槽可以装多少单位的水？
- 分析：当前墙体可以乘水的单位由左右两边的墙体高度决定;
- >求解i能够乘水的单位trap[i]，求和得到能够乘水的最大值
- >i的乘水量 trap[i]由左边和右边最低的决定:trap[i] = min(left[i],right[i])-height[i]
- > trap[i] <=0.则trap[i] = 0 ；否则为trap[i]
- >left[i]和right[i]求解：动态规划
- 子问题：left[i]的值如何计算？
- >max(left[i-1],height[i-1]) : 当前左边最大值，有左边第一个值和左边的maxleft决定
- >right同理
- 238 构建一个数组，值是除自己以外的其他数的乘积,要求O(n)，不使用除法
- > 子问题：pro[i] = left[i-1] * right[i+1] ,分为左右两边求解，同42
-> left[i] = num[i-1] * left[i-1]

### 背包问题
#### 01背包：n个物品，w[i]为第i个物品的的重量，v[i]第i个物品的价值，背包承重w，要求放入的价值最大：
- > 状态转换：dp[i][j] 为前i个物品放入重量为j的背包的最大价值：两种情况决定最大价值，i放入和不放入的最大值（i-1实际代表第i个物品）
- > 1.i不放入背包的最大价值：dp[i-1][j]
- > 2.i放入背包，则背包承重变为j-w[i]:dp[i-1][j-w[i-1]]+v[i-1];此处i-1因为物品不能重复放入
- > dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i-1]]+v[i-1]);j>=w[i-1]
- > 优化空间j必须反向遍历
#### 完全背包问题：与01背包的不同在于同一个物体可以无限重复放入
- > 状态转换： dp[i][j] = max(dp[i-1][j],dp[i][j-w[i-1]]+v[i-1]);j>=w[i-1]；与01背包的不同在于dp[i][j-w[i-1]]+v[i-1])，第一维索引为i，表示i可以重复放入
- > 优化空间j必须正向遍历
- 多重背包问题：不同点在于引入了n[i] 表示第i总物品有多少个
- > 状态转换：考虑装入i物品的件数：k为装入i物品的件数（0...n[i]）= min(n[i],j/w[i])
- > dp[i][j] = max(dp[i-1][j-k*w[i]]+ k*v[i] for every k)
#### no 518 回溯算法解决重复问题代价较大，寻找dp算法解决：amount = 5, coins = [1,2,5]
- >子问题：dp[i][j] 为前i个coins组合成j的组合总数；两种情况：coins[i-1]为对应第i个硬币，使用和不使用第i个的组合数相加，决定了总的组合数
- > 1. 不使用第i个硬币的组合j的情况：j<coin[i-1];dp[i][j] = dp[i-1][j];
- > 2. 使用第i个硬币的情况，由于相同硬币可以重复使用（dp[i][j-coins[i-1]]第一维索引为i）：
- >  j>=coin[i-1]；dp[i][j] = dp[i-1][j] +dp[i][j-coins[i-1]] ; j-coins[i-1] 表示j已经加入了一个硬币i
### 其他
- no 1524 获取数组中所有子数组中和为奇数的子数组的个数 (子数组元素必须连续)；递归法超时
- > dp0[i] 表示以i为开头的子数组的和为奇数和的子数组个数；dp1[i] 相反
- > 状态转换：
- > 1.第i个元素为奇数，则dp0[i] = dp1[i+1]（奇数数组尽数转换为偶数） dp1[i] = dp0[i+1] + 1(1为第i个元素本身)
- > 2.1.第i个元素为偶数，则dp1[i] = dp0[i+1] dp0[i] = dp1[i+1] + 1(1为第i个元素本身)
- > 3.结果为dp1[i]的和
## 图
### 广度优先
### 最短路径算法（动态规划）（bellman-ford）：边的权重可以为负数，n为节点个数 时间复杂度O（VE）
- 输入：边集合：[i,j,w];点集合；距离集合Distant；起始点
- Distant[i]:为源点到i点的最短距离；初始时设置 Distant[原点] = 0，其他的为无穷大
- 松弛计算：对所有边，若Distant[j] > Distant[i] + w[i,j],则Distant[j]= Distant[i] + w[i,j]；i为边的起点，j为边的终点
- 计算最短路径：进行n-1轮的松弛计算；第一轮更新原点相隔一条表的节点；第二轮两条边可达的距离；n-1轮正好覆盖最差情况（n个节点串联）；若某轮没有更新Distant，则结束
- 负环路：权值之和为负数的环路；存在则无法求出最短路径；遍历所有边，若依然存在Distant[j] > Distant[i] + w[i,j]，则有环路，无法求解最短路径
```
dist := make([][]int, n)//到原点的距离
edges [][]int{起始点，终点，权重} //边集合，邻接矩阵
	// n-1轮循环
for i := 0; i < n-1; i++ {
	    check := false
		   // 遍历所有边，进行松弛
	for _, v := range edges {
		if dist[v[1]][0] > dist[v[0]][0]+v[2] {
			dist[v[1]][0] = dist[v[0]][0] + v[2]
			check = true
		}
	}

	if !check {
		break
	}
}	
```
- no 787 找到最多K次中转的最便宜的航班路径
- > 状态转移：dp[k][j] 为需要i次中转的终点为j的价格；0<=k<=K+2;0<=0<=n
-> dp[k][j] = min(dp[k][j],dp[k-1][i]+w[i,j])
### Dijkstra（贪心策略） ： 处理单源最短路径，边的权重不能为负数，适用于有向图和无向图，图可以包含环路 o（v^2）
- 思路：每次选取未加入集合的，离原点最近的点；加入集合，并以该点为起点，更新到原点的距离
- 输入：原点v；顶点集合；边集合包含点和权重[i,j,w]；dist[n] 原点到节点的距离；prev[]记录当前点的前一个节点；已计算的的点集合s[]
- 初始化：初始化s[v] =1,其他为0；初始化prev和dist
- 计算：遍历节点，找出未放入s的节点中，找到dist最小的，将节点放入s； 以新加入的点为起始，更新dist和prev
- 通用模式
```
  dist := make([]int, n) //保存到原点距离
	path := make([]int, n) //保存到原点path，可选
	set := make(map[int]bool) // 判定点是否被选定
  adj := make([][]int, n) //邻接矩阵，值为权重
  // 初始化
  adj[src]可发现的边初始化
  set[src]初始化
  dist和path初始化
  // 计算
  for i := 0; i < n; i++ {
       min := INF //最小值保存
		   selectNode := 0 //旋转节点保存
      //寻找节点              
      for j := 0; j < n; j++ {
        if !set[j] && dist[j] < min {
				min = dist[j]
				selectNode = j
			  }
      }
      // 保存节点                             
      set[selectNode] = true
      //从新选节点出发，更新        dist和path                     
      for j := 0; j < n; j++ {
        if !set[j] && min+adj[selectNode][j] < dist[j] {
          dist[j] = min + adj[selectNode][j]
          path[j] = selectNode
			  }
      }

  }
  
```
### Floyd：任意两个节点间的最短路径 o(v^3) 在任何图中使用，包括有向图、带负权边的图;邻接矩阵来储存边
- 思路： 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短
 ```
  For k←1 to n do // k为“媒介节点”
   For i←1 to n do
      For j←1 to n do
         if (dist(i,k) + dist(k,j) < dist(i,j)) then // 是否是更短的路径？
            dist(i,j) = dist(i,k) + dist(k,j)
 ```
