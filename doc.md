# 算法思路总结

## 字符串
- 14 最长公共前缀（后缀）：依次比较每个字符，比较次数=最短字符串的长度

## 整数
- 7 有符号整数反转（考察边界）: 由于反转过程中值会溢出，所以中间值和maxINT/10 和minInt/10比较
- > 最大有符号整形：int32(^uint32(0)>>1),0按位取反，全为1，左移1位，则最高位为0，其余位位1
- > 最小有符号整形：最大整形取反，符号位为1，其他位为0
## 数组
- 数组反转：首尾依次交换

### 双索引法
- 345 数组部分反转：操作快排，首尾同时遍历；条件满足则交换；否则需要继续移动坐标
- 11 数组区间，求哪两个柱子之间可以灌最多的水？
- > 面积最大的灌水最多，遍历所有的柱子组合：面积计算：（j-i）* min(a[i],a[j])
- > 计算第一个和最后一个的面积。
- > 如何得到更大的面积？提高最短边的长度。从两侧分别遍历，交替提高短边的高度
## 动态规划
- dp二维数组的求解方向：画出矩阵，要求先计算的值能够为后面计算提供解：
```
<!-- 倒金字塔填充dp -->
row ： n->0
col :  row->n
1 1 1
  1 1
    1
```
### 回文
- 5 最大回文子串 516 最大回文子序列：
- > 子问题：dp[i][j]是回文需要满足什么条件？0<=i<n,i<=j<n
- > 1.s[i] == s[j] 且 dp[i+1][j-1]是回文串
- > 2.i==j
- > 3.s[i] == s[j] 且 j-i == 1
- 516 最大回文子序列，不需要连续字符
  ```
  Input: s = "bbbab"
  Output: 4 (bbbb)
  ```
- > 子问题：dp[i][j]=k，i，j所代表的子串有k个字符可构成回文；0<=i<n,i<=j<n;k<=j-i+1
- > 1j-i == 0; dp[i][j] = 1
- > 2 j-i == 1; 且 s[i] == s[j]; dp[i][j] = 2
- > 3.j-i > 1 ,s[i] == s[j];dp[i][j] = dp[i+1][j-1] + 2
- > 4.s[i] != s[j]; dp[i][j] = max(dp[i+1][j],dp[i][j-1])
- >5.2和3综合为：s[i] == [j],则;dp[i][j] = dp[i+1][j-1] + 2
### 数组
- 42 数字代表墙，求墙体的凹槽可以装多少单位的水？
- 分析：当前墙体可以乘水的单位由左右两边的墙体高度决定;
- 求解i能够乘水的单位trap[i]，求和得到能够乘水的最大值
- i的乘水量 trap[i]由左边和右边最低的决定:trap[i] = min(left[i],right[i])-height[i]
- trap[i] <=0.则trap[i] = 0 ；否则为trap[i]
- left[i]和right[i]求解：动态规划
- 子问题：left[i]的值如何计算？
- max(left[i-1],height[i-1]) : 当前左边最大值，有左边第一个值和左边的maxleft决定
- right同理
