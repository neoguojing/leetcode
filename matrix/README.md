## 矩阵
### 矩阵旋转：顺时针90度：则转置+左右变化；逆时针90度：则转置+上下变化;旋转180度：则等于旋转2个90度
-  转置：i:=0 j:=i+1 matrix[i][j] = matrix[j][i]
- 旋转的坐标变化： 90度： i,j => j,n-i-1  180度：i,j => n-i-1,n-j-1 270度：i,j => n-j-1, i
- no 73 将矩阵为0的行和列置为0 空间复杂度为1；1.使用第一行和第一列保存需要置0的行和列；需要先确认第0行和列是否需要置0
- no 36 判断数独是否合法：即每行，每列和3*3格子无重复元素；使用map，分别对行和列已经格子的元素判断重复，使用字符串拼接
- no 48 n*n的矩阵，原地顺时针旋转90度；
- no 1886 确认矩阵是否通过旋转可以得到目标矩阵（90度，180 270）：使用坐标转换公式，依次比较；初始数据要置为true
### 矩阵螺旋遍历
- 使用4个遍变量分别标记行和列的起始和结束位置；一个变量标记方向；循环结束条件是起始小于结束
- no 54 矩阵的顺时针螺旋排序输出
- no 59 1-n平方的数填到n*n的矩阵里
- no 885 从某点开始以顺时针螺旋状步长为1，遍历整个矩阵，可以溢出到矩阵外面；返回遍历路径
- > 行列起始和结束需要表示，方向需要表示；结束条件为行列头尾需要在合法范围内；在向右遍历完之后，扩大行列头尾的范围；注意：需要考虑角上元素是否重复
### 矩阵搜索
- 维护已访问位置，防止出现环；在条件失败时，需要重置位置
```
	if 目标索引越界 返回
	if 矩阵越界 返回
	if 位置已访问 返回
	if 条件不满足 返回
	
	上下左右分别递归
	返回
```
- no 79 在由字母构成的图中，检索是否存在单词；位置需要连续
- no 240 矩阵的每行（左-》右）和每列（上-》下）都是有序的，快速搜索某个值: 1.从右上角开始搜索 ；2.使用二分查找
### 矩阵面积求解
- 221 求解矩阵中由1组成的最大面积的正方形：dp[i][j] 表示以（i，j）为右下角的正方形的边长；dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1
- 85 求解矩阵中由1组成的最大面积的矩形：参考84，将矩阵转换为每一行的柱状图求面积
## 排序
### 列表排序 一般使用归并排序 o(nlogn) o(1)
- 列表获取中值：添加一个虚拟头，两个指针，一个移动2步，一个移动一步；条件是：快指针不等于nil和next不能nil； 注意，最终需要拿到的是中值的前值，然后需要断掉中值直接的链接
- 归并：添加一个虚拟头，遍历依次顺着虚拟头插入；需要一个指针记录当前位置
-  no 128 对一个列表进行排序：归并排序，获取中止，递归，然后合并
- no 147 列表的插入排序：需要一个虚拟头；一个p指向当前位置；注意：每轮循环结束，已旋转列表的头需要重置
### 有限元素类型的排序问题
- no 75 三种颜色，0，1，2，将相同颜色连在一起，且按照0，1，2的顺序排序
- > 因为值的个数是3种，我们只关心0和2（首尾），排好序后，中间的就是1
- > 算法实现： 两个变量，记录当前最后一个0和最前一个2的位置；遍历数组，遇到2交换到后面；重新判断当前位置为1则继续，为0则交换到前面的位置继续
