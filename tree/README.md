## 树
### 二叉索引树
- 场景：适用于求数组的前缀和（sum[i] = a[0]+...a[i]） 区间和；
- 构建 o（NlogN） 空间 o（N），搜索和更新o（LogN）
- 特征：树总共n+1个节点；对于n+1个节点的根节点代表索引0，不存储任何信息；
- lowbit: lowbit(1) = 1 lowbit(2) = 2 lowbit(3) = 1 lowbit(4) = 4
- 原理：父节点定义：parent(i) = i - (i &(-i)) 即索引的值减去索引的的lowbit所对应的值；如1，2，4的父节点是0；3的父节点是2，5，6的父节点是4
- > 节点的值： a[i] = nums[i] + nums[i-lowbit(i)] ... 
### 区间树
- 场景：区间查询和更新；如求区间最大值，区间最小值或区间亦或值查询等
- 数据结构： 使用数组保存树结构；根节点代表[0,n)；根节点被对半划分为连个区间，用两个子树表述；叶节点对应单个元素的值；
### 二叉树 
- 先序：中左右 中序：左中右 后序：左右中
- 基于栈的遍历：循环条件栈不为空（中序情况下加上当前节点不为nil）；原则：先访问的后入栈
- 1.先序：根先入栈；右子树先入栈，左子树后入栈；
- 2.中序：根不入栈；左子树全部入栈；出栈（访问）；当前指针指向右节点
- 3.后序：原则：根在栈底，随后右子树，随后左子树；根入栈两次;出栈；右节点入栈两次；左节点入栈两次； 入栈两次节点的意义：第一次用于最终的遍历输出；第二次用于找到该节点的左右节点（）
- no 101 判断二叉树是否中心对称：使用递归
- no 103 z型遍历：1.和层序遍历一样，只需要记录方向，在逆向是反转数组；2.反转遍历改为从后往前插入
### 二叉树搜索树
- no 98 二叉搜索树（左小右大）是否合法，中序遍历：1.先判断根节点取有效整数范围（以int64最大和最小为边界）；2.左子树的取值范围（-minint64,root) ，右节点（root，maxint64）；3.先判断根，然后判断左子树，左子树正确才判断右子树
- no 230 返回二叉搜索树上第K个最小的值 :中序遍历直到k==0；
- > 递归：k需要作为指针传递，返回值最好也作为指针传递，方便计算；或者将遍历的元素保存到数组；对从最终的数组取k个元素
### 构建二叉树
- 先序遍历的特点，第一个元素是根节点；依据左右子树节点的个数，可以划分左右子树
- 中序遍历特点：根节点的左侧属于左子树，能够依据根节点，划分左右子树；根节点索引的位置，可以计算左右子树节点的个数
- 后续遍历的特点：最后一个为根；依据左右节点的个数，可以划分左右子树
- 105 依据先序遍历和中序遍历构造二叉树：1.依据先序遍历的第一个节点，建立根；2.找到中序遍历中的根的索引；对于先序遍历依据中序遍历根索引位置，可以确认左右子树的个数；3.递归建立左子树和右子树
- 106 依据中序遍历和后续遍历，还原二叉树：1.依据后序遍历的最后一个节点，建立根；2.找到中序遍历的根节点索引，计算左右子树的节点个数；3.递归建立左右子树
- 889 通过先序和后续遍历构建二叉树：以先序遍历第一个节点作为根，若根的值不等于后序遍历的当前值，则递归左子树和右子树
- 108 有序数组转换为平衡二叉搜索树：适用二分查找，中间位置为树根，左右为左右子树，适用递归
- 109 右序列表构建平衡二叉搜索树：同上，适用快慢指针寻找中间位置
### 多叉树遍历 中序遍历无意义
- 先序遍历：1.使用栈；2.递归，子节点从左到右递归
- 后序遍历：1.递归：先遍历子节点递归，然后访问根节点
### BFS 广度优先遍历 使用queue  层序遍历，使用q的size作为出栈入栈的数量控制
- 429 多叉树的层序遍历；1.根节点入堆；2.出队直到队列为空：访问元素，并收集下层的所有节点；3.遍历下层节点，入队
- no 102 二叉树的层序遍历：同429，只是需要判断left 或right是否为空
### LCA 问题 最近公共祖先问题
- 235 二叉搜索树的两个元素的公共祖先：由于搜索树的特性：若根大于p小于q则根是公共祖先；q,p比根小，则根指向左子树，否则同理：1.递归；2.遍历 技巧(root.val -p.val) * (root.val-q.val) > 0
- 236 普通二叉搜索树的的LCA问题：1.使用层序遍历，遍历树，标记节点的父节点，构成并查集；遍历并查集，直到p和q的祖先一样；2.递归：边界 root 为nil，root为p或q，则返回root；分别递归左边和右边，根据左边和右边的值（nil 或非 nil）筛选结果
### trie 前缀树
- 用于自动完成字符，字符搜索，前缀搜索等，功能包括：插入，搜索和前缀搜索
- 实现：1.根不存储数据；2.节点：a.是否是页节点；b.一个map
```
type TrieNode struct {
	isLeaf   bool
	children map[rune]*TrieNode
}
```
- no 208 648 211
### 路径和
- 124:二叉树中的权重最长的路径 路径不一定经过根,递归:
- > 1.最大路径经过root，在左子树，在由子树，三种情况，可以归结为比较三种情况的大小，使用递归；
- > 2.对于小于0的节点，无需计算
- 543 ：同124 ,求二叉树的直径（最长路径，可以不经过根）：注意：路径等于顶点个数减1
- 112 判断是否有一条从根节点到叶子节点的路径，该路径上所有数字的和等于sum： 使用递归分别判断左右子树
- 113 输出一条从根节点到叶子节点的路径，该路径上所有数字的和等于sum：同上
- 437：路径和等于targetSum，路径可以不经过根，且路径方向朝下（必定在某条从根节点到叶子的路径上）:将每个子节点当作根，计算该路径上的和的情况
